{"meta":{"title":"我不是诸葛亮","subtitle":"宁可碌碌，不可无为","description":" iOS developer","author":"zhuguanliang","url":"http://example.com","root":"/"},"pages":[{"title":"404 Not Found","date":"2019-09-22T02:41:27.000Z","updated":"2021-05-12T05:51:31.894Z","comments":true,"path":"404.html","permalink":"http://example.com/404.html","excerpt":"","text":"对不起，您所访问的页面不存在或者已删除。 您可以点击此处返回首页。 NightTeam"},{"title":"tags","date":"2021-05-12T05:35:59.000Z","updated":"2021-05-12T05:39:20.011Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":"type: tagscomments: false"}],"posts":[{"title":"适合学习——swift版基于MVVM模式的网络API调用Demo","slug":"MVVM的网络API调用Demo","date":"2021-02-22T04:49:00.000Z","updated":"2021-02-22T06:49:00.000Z","comments":true,"path":"2021/02/22/MVVM的网络API调用Demo/","link":"","permalink":"http://example.com/2021/02/22/MVVM%E7%9A%84%E7%BD%91%E7%BB%9CAPI%E8%B0%83%E7%94%A8Demo/","excerpt":"","text":"学习目标： 以纯代码方式构建完整的应用，使用 NSCache 缓存图像 学习网络API的调用 学习MVVM设计模式 学习构建可重用视图 自定义带阴影的图像视图 API取自https://newsapi.org，自己申请下APIKey，完全免费，如上不了网页请用科学方法试试 项目目录结构如下 以纯代码方式创建应用SceneDelegate的代码进行修改，定义下初始视图控制器 12345678guard let windowScene = (scene as? UIWindowScene) else &#123; return &#125;window = UIWindow(windowScene: windowScene)window = UIWindow(frame: UIScreen.main.bounds)window?.windowScene = windowScenelet viewController = ViewController()window?.rootViewController = viewControllerwindow?.makeKeyAndVisible() 同时删除main与Main.storyboard 创建视图模型创建APIkey 创建模型 12345678910111213141516import Foundationstruct News: Decodable &#123; let author : String? let title : String? let description : String? let url : String? let urlToImage : String? &#125;struct NewsEnvelope: Decodable &#123; let Status : String? let totalResuls : String? let articles : [News] 创建网络服务NetworkManager.swift 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import Foundationclass NetworkManager &#123; let imageCache = NSCache&lt;NSString,NSData&gt;() static let shared = NetworkManager() private init () &#123;&#125; private let baseUrlString = &quot;https://newsapi.org/v2/&quot; private let USTopHeadline = &quot;top-headlines?country=us&quot; func getNews(Completion: @escaping ([News]?) -&gt; Void) &#123; let urlString = &quot;\\(baseUrlString)\\(USTopHeadline)&amp;apikey=\\(APIKey.key)&quot; guard let url = URL(string: urlString) else &#123; return &#125; URLSession.shared.dataTask(with: url) &#123; (date, response, error) in guard error == nil, let data = date else&#123; Completion(nil) return &#125; let newsEnvelope = try? JSONDecoder().decode(NewsEnvelope.self, from: data) newsEnvelope == nil ? Completion(nil) : Completion(newsEnvelope!.articles) &#125;.resume() &#125; func getImage(urlString: String,Completion: @escaping (Data?) -&gt; Void) &#123; guard let url = URL(string: urlString) else &#123; Completion(nil) return &#125; if let cachedImage = imageCache.object(forKey: NSString(string: urlString)) &#123; Completion(cachedImage as Data) &#125;else &#123; URLSession.shared.dataTask(with: url) &#123; (date, response, error) in guard error == nil, let data = date else&#123; Completion(nil) return &#125; self.imageCache.setObject(date as! NSData, forKey: NSString(string: urlString)) Completion(date) &#125;.resume() &#125; &#125; &#125; 创建网络服务NewViewModel.swift 123456789101112131415161718192021222324252627282930import Foundationstruct NewsViewModel &#123; let news : News var author : String &#123; return news.author ?? &quot;Unknown&quot; &#125; var title : String &#123; return news.title ?? &quot;&quot; &#125; var description : String &#123; return news.description ?? &quot;&quot; &#125; var url : String &#123; return news.url ?? &quot;&quot; &#125; var urlToImage : String &#123; return news.urlToImage ?? &quot;https://www.kindpng.com/picc/m/182-1827064_breaking-news-banner-png-transparent-background-breaking-news.png&quot; &#125; &#125; 创建NewsListViewModel.swift123456789101112131415161718import Foundationclass NewsListViewModel &#123; var newsVM = [NewsViewModel]() let reauseID = &quot;news&quot; func getNews(Completion: @escaping ([NewsViewModel]) -&gt; Void) &#123; NetworkManager.shared.getNews &#123; (news) in guard let news = news else &#123; return &#125; let newsVM = news.map(NewsViewModel.init) DispatchQueue.main.async &#123; self.newsVM = newsVM Completion(newsVM) &#125; &#125; &#125;&#125; 创建NewsTableViewCell.swift123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475import UIKitfinal class NewsTableViewCell : UITableViewCell &#123; var newsVM: NewsViewModel? &#123; didSet&#123; if let newsVM = newsVM &#123; titleLabel.text = newsVM.title NetworkManager.shared.getImage(urlString: newsVM.urlToImage) &#123; (data) in guard let data = data else &#123; return &#125; DispatchQueue.main.async &#123; self.newsImage.image = UIImage(data: data) &#125; &#125; &#125; &#125; &#125; var newsImageData: Data? &#123; didSet&#123; if let data = newsImageData &#123; newsImage.image = UIImage(data: data) &#125; &#125; &#125; private lazy var newsImage: ShadowImageView = &#123; let v = ShadowImageView() v.translatesAutoresizingMaskIntoConstraints = false return v &#125;() private lazy var titleLabel: UILabel = &#123; let v = UILabel() v.translatesAutoresizingMaskIntoConstraints = false v.numberOfLines = 0 return v &#125;() override init(style: UITableViewCell.CellStyle, reuseIdentifier: String?) &#123; super.init(style: style, reuseIdentifier : reuseIdentifier) selectionStyle = .none setupView() &#125; required init?(coder: NSCoder) &#123; fatalError(&quot;init(coder:) has not been implemented&quot;) &#125; func setupView() &#123; addSubview(titleLabel) addSubview(newsImage) setupConstraints() &#125; func setupConstraints() &#123; //news image NSLayoutConstraint.activate([ newsImage.leadingAnchor.constraint(equalTo: leadingAnchor), newsImage.trailingAnchor.constraint(equalTo: trailingAnchor), newsImage.topAnchor.constraint(equalTo: topAnchor), newsImage.heightAnchor.constraint(equalToConstant: 200) ]) //title NSLayoutConstraint.activate([ titleLabel.leadingAnchor.constraint(equalTo: leadingAnchor, constant: 16), titleLabel.trailingAnchor.constraint(equalTo: trailingAnchor, constant: -16), titleLabel.topAnchor.constraint(equalTo: newsImage.bottomAnchor, constant: 8), titleLabel.bottomAnchor.constraint(equalTo: bottomAnchor, constant: -16) ]) &#125; &#125; 创建阴影ShadowImageView.swift1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import UIKitfinal class ShadowImageView : UIView &#123; var image: UIImage? &#123; didSet&#123; imageView.image = image &#125; &#125; private lazy var imageView : UIImageView = &#123; let v = UIImageView() v.translatesAutoresizingMaskIntoConstraints = false v.contentMode = .scaleAspectFill v.layer.cornerRadius = 20 v.clipsToBounds = true return v &#125;() private lazy var baseView : UIView = &#123; let v = UIView() v.translatesAutoresizingMaskIntoConstraints = false v.backgroundColor = .clear v.layer.shadowColor = UIColor.black.cgColor v.layer.shadowOffset = CGSize(width: 5, height: 5) v.layer.shadowOpacity = 0.7 v.layer.cornerRadius = 10 return v &#125;() init() &#123; super.init(frame: .zero) setupView() &#125; required init?(coder: NSCoder) &#123; fatalError(&quot;init(coder:) has not been implemented&quot;) &#125; func setupView() &#123; addSubview(baseView) baseView.addSubview(imageView) setupConstraints() &#125; func setupConstraints() &#123; [baseView, imageView].forEach &#123; (v) in NSLayoutConstraint.activate([ v.leadingAnchor.constraint(equalTo: leadingAnchor, constant: 16), v.trailingAnchor.constraint(equalTo: trailingAnchor, constant: -16), v.topAnchor.constraint(equalTo: topAnchor, constant: 16), v.bottomAnchor.constraint(equalTo: bottomAnchor, constant: -16) ]) &#125; func layoutSubviews() &#123; super.layoutSubviews() baseView.layer.shadowPath = UIBezierPath(roundedRect: baseView.bounds, cornerRadius: 10).cgPath baseView.layer.shouldRasterize = true baseView.layer.rasterizationScale = UIScreen.main.scale &#125; &#125;&#125; 创建HeaderView.swift12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788import UIKitfinal class HeaderView : UIView &#123; private var fontSize: CGFloat private lazy var headinglabel : UILabel = &#123; let v = UILabel() v.translatesAutoresizingMaskIntoConstraints = false v.text = &quot;新闻&quot; v.font = UIFont.boldSystemFont(ofSize: fontSize) return v &#125;() private lazy var headingCircImage : UIImageView = &#123; let v = UIImageView() v.translatesAutoresizingMaskIntoConstraints = false v.contentMode = .scaleAspectFit let config = UIImage.SymbolConfiguration(pointSize: fontSize, weight: .bold) v.image = UIImage(systemName: &quot;btn_live_selected.png&quot;, withConfiguration: config)?.withRenderingMode(.alwaysOriginal) return v &#125;() private lazy var plusImage: UIImageView = &#123; let v = UIImageView() v.translatesAutoresizingMaskIntoConstraints = false let config = UIImage.SymbolConfiguration(pointSize: fontSize, weight: .bold) v.image = UIImage(systemName: &quot;plus&quot;, withConfiguration: config)?.withRenderingMode(.alwaysOriginal) return v &#125;() private lazy var subheadlineLabel: UILabel = &#123; let v = UILabel() v.translatesAutoresizingMaskIntoConstraints = false v.font = v.font.withSize(fontSize) v.text = &quot;Top Headlines&quot; v.textColor = .gray return v &#125;() private lazy var headerStackView: UIStackView = &#123; let v = UIStackView(arrangedSubviews: [headingCircImage, headinglabel, plusImage]) v.translatesAutoresizingMaskIntoConstraints = false v.axis = .horizontal return v &#125;() init(fontSize: CGFloat)&#123; self.fontSize = fontSize super.init(frame: .zero) translatesAutoresizingMaskIntoConstraints = false setupView() &#125; required init?(coder: NSCoder) &#123; fatalError(&quot;init(coder:) has not been implemented&quot;) &#125; func setupView() &#123; addSubview(headerStackView) addSubview(subheadlineLabel) setupConstraints() &#125; func setupConstraints() &#123; //new header NSLayoutConstraint.activate([ headerStackView.leadingAnchor.constraint(equalTo: leadingAnchor), headerStackView.topAnchor.constraint(equalTo: topAnchor) ]) //subheadline NSLayoutConstraint.activate([ subheadlineLabel.leadingAnchor.constraint(equalTo: leadingAnchor), subheadlineLabel.topAnchor.constraint(equalTo: headerStackView.bottomAnchor, constant: 8), subheadlineLabel.bottomAnchor.constraint(equalTo: bottomAnchor) ]) &#125;&#125;","categories":[],"tags":[]},{"title":"斗鱼直播Demo(二)","slug":"斗鱼直播Demo2","date":"2020-05-18T05:49:59.000Z","updated":"2020-12-30T06:49:00.000Z","comments":true,"path":"2020/05/18/斗鱼直播Demo2/","link":"","permalink":"http://example.com/2020/05/18/%E6%96%97%E9%B1%BC%E7%9B%B4%E6%92%ADDemo2/","excerpt":"","text":"封装PageConnetView（滚动内容）在view新建PageContentView.swift （cocoa） 封装构造函数定义属性，封装构造函数 1234567891011121314151617181920import UIKitclass PageContentView: UIView &#123; // MARK:- 定义属性 private var childVcs : [UIViewController] private weak var parentViewController : UIViewController? // MARK:- 自定义构造函数 init(frame: CGRect, childVcs : [UIViewController], parentViewController : UIViewController?) &#123; self.childVcs = childVcs self.parentViewController = parentViewController super.init(frame: frame)&#125; required init?(coder aDecoder: NSCoder) &#123; fatalError(&quot;init(coder:) has not been implemented&quot;) &#125;&#125; 在Extension扩展处给UIColor扩充一个UIColor-Extension.swift扩展 1234567import UIKitextension UIColor &#123; convenience init(r : CGFloat, g : CGFloat, b : CGFloat) &#123; self.init(red: r / 255.0, green: g / 255.0, blue: b / 255.0, alpha: 1.0)//遍历构造函数 &#125;&#125; 转到homeVC懒加载 12345678910111213private lazy var pageContentView : PageContentView = &#123;[weak self] in // 1.确定内容的frame let contentH = kScreenH - KStatusBarH - kNavigationBarH - KTitleViewH let contentFrame = CGRect(x: 0, y: KStatusBarH + kNavigationBarH + KTitleViewH, width: kScreenW, height: contentH) // 2.确定所有的子控制器 var childVcs = [UIViewController]() for _ in 0..&lt;4 &#123; let vc = UIViewController() vc.view.backgroundColor = UIColor(r: CGFloat(arc4random_uniform(255)), g: CGFloat(arc4random_uniform(255)), b: CGFloat(arc4random_uniform(255))) childVcs.append(vc) &#125; 然后到底部添加ContentView，为了能看到，还给其定义个颜色 1234// 3.添加ContentViewview.addSubview(pageConten pageContentView.backgroundColor = UIColor.purple//添加可是颜色tView) 运行项目，发现添加上 给里面添加布局，设置UI界面，回到PageContentView.swift将所有的子控制器添加父控制器中，在最后添加 123456789// MARK:- 设置UI界面extension PageContentView &#123; fileprivate func setupUI() &#123; // 1.将所有的子控制器添加父控制器中 for childVc in childVcs &#123; parentViewController?.addChild(childVc) &#125; &#125;&#125; 添加懒加载属性 ``` // MARK:- 懒加载属性 private lazy var collectionView : UICollectionView = { // 1.创建layout let layout = UICollectionViewFlowLayout() layout.itemSize = self.bounds.size layout.minimumLineSpacing = 0 //行间距 layout.minimumInteritemSpacing = 0 layout.scrollDirection = .horizontal //滚动方向水平滚动 // 2.创建UICollectionView let collectionView = UICollectionView(frame: CGRect.zero, collectionViewLayout: layout) collectionView.showsHorizontalScrollIndicator = false collectionView.isPagingEnabled = true collectionView.bounces = false return collectionView &#125;() 12345转到代码下方**extension**里添加UICollectionView,用于在Cell中存放控制器的View // 2.添加UICollectionView,用于在Cell中存放控制器的View addSubview(collectionView) collectionView.frame = bounds 123456789101112131415同时把设置UI添加![image-20201224235251519](https://gitee.com/zhu565615430/images/raw/master/CBcityimas/image-20201224235251519.png)运行，CollectionView没有内容，但可以显示（黑的）&lt;img src=&quot;https://gitee.com/zhu565615430/images/raw/master/CBcityimas/image-20201224235319031.png&quot; alt=&quot;image-20201224235319031&quot; style=&quot;zoom:50%;&quot; /&gt;给其添加设置数据源![image-20201224235533496](https://gitee.com/zhu565615430/images/raw/master/CBcityimas/image-20201224235533496.png) collectionView.dataSource = self 12345678910111213141516171819202122232425- 添加数据源要遵守协议，在最下方添加扩展- ``` // MARK:- 遵守UICollectionViewDataSource extension PageContentView : UICollectionViewDataSource &#123; func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -&gt; Int &#123; return childVcs.count &#125; func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -&gt; UICollectionViewCell &#123; // 1.创建Cell let cell = collectionView.dequeueReusableCell(withReuseIdentifier: ContentCellID, for: indexPath) // 2.给Cell设置内容 for view in cell.contentView.subviews &#123; view.removeFromSuperview() &#125; let childVc = childVcs[(indexPath as NSIndexPath).item] childVc.view.frame = cell.contentView.bounds cell.contentView.addSubview(childVc.view) return cell &#125; &#125; 1.创建cell必须注册cell,添加 1collectionView.register(UICollectionViewCell.self, forCellWithReuseIdentifier: ContentCellID)//注册cell 注册完在上方添加后面的标识报错消失 1private let ContentCellID = &quot;ContentCellID&quot;//添加标识 2.给cell设置内容，如1代码 运行，滚动实现 4.给代码进行优化 闭包里面用self会产生循环引用，给用weak ```private lazy var collectionView : UICollectionView = {[weak self] in // 1.创建layout let layout = UICollectionViewFlowLayout() layout.itemSize = (self?.bounds.size)!//可选链返回值是可选值，（）强制解包 12345678910111213 homeVC,前面以改![image-20201225091330746](https://gitee.com/zhu565615430/images/raw/master/CBcityimas/image-20201225091330746.png) ## 封装PageTitleView&amp;PageConnetView的逻辑### PageTitleView发生点击- ###### 将PageTitleView中逻辑进行处理 - ![image-20210108150907265](https://gitee.com/zhu565615430/images/raw/master/CBcityimas/image-20210108150907265.png) extension PageTitleView { @objc fileprivate func titleLabelClick(_ tapGes : UITapGestureRecognizer) { // 1.获取当前Label guard let currentLabel = tapGes.view as? UILabel else &#123; return &#125; // 2.获取之前的Label let oldLabel = titleLabels[currentIndex] // 3.切换文字的颜色 currentLabel.textColor = UIColor.orange oldLabel.textColor = UIColor.darkGray // 4.保存最新Label的下标值 currentIndex = currentLabel.tag // 5.滚动条位置发生改变 let scrollLineX = CGFloat(currentIndex) * scrollLine.frame.width UIView.animate(withDuration: 0.15, animations: &#123; self.scrollLine.frame.origin.x = scrollLineX &#125;) // 6.通知代理 delegate?.pageTitleView(self, selectedIndex: currentIndex) &#125; } 1234567891011###### 给Label添加手势![image-20201225092417833](https://gitee.com/zhu565615430/images/raw/master/CBcityimas/image-20201225092417833.png) // 5.给Label添加手势 label.isUserInteractionEnabled = true let tapGes = UITapGestureRecognizer(target: self, action: #selector(self.titleLabelClick(_:))) label.addGestureRecognizer(tapGes)//添加手势到label 123456789**extension**给label添加监听![image-20201225092349310](https://gitee.com/zhu565615430/images/raw/master/CBcityimas/image-20201225092349310.png)获取当前Label的下标值前，先默认currentIndex![image-20201225092839764](https://gitee.com/zhu565615430/images/raw/master/CBcityimas/image-20201225092839764.png) private var currentIndex : Int = 0 123之前前Label的下标值的处理（添加了） let oldLabel = titleLabels[currentIndex] 123保存最新Label的下标值（添加了） // 4.保存最新Label的下标值 currentIndex = currentLabel.tag 123456789切换文字的颜色&lt;img src=&quot;https://gitee.com/zhu565615430/images/raw/master/CBcityimas/Dec-25-2020%2012-15-52.gif&quot; alt=&quot;Dec-25-2020 12-15-52&quot; style=&quot;zoom:50%;&quot; /&gt;文字颜色修改了，但是方的线————滚动条没发生滚动设置滚动条位置发生改变 // 5.滚动条位置发生改变 let scrollLineX = CGFloat(currentIndex) * scrollLine.frame.width UIView.animate(withDuration: 0.15, animations: &#123; self.scrollLine.frame.origin.x = scrollLineX &#125;) 1234567内容滚动，通过代理把PageConnetView发生的事件传递给homeVC在PageTitleView.swift头部定义协议![image-20201225141758688](https://gitee.com/zhu565615430/images/raw/master/CBcityimas/image-20201225141758688.png) // MARK:- 定义协议protocol PageTitleViewDelegate : class {//class表示协议只能被类取走 func pageTitleView(_ titleView : PageTitleView, selectedIndex index : Int) } 123 weak var delegate : PageTitleViewDelegate?//定义代理属性 12345接着在下方通知代理![image-20201225142217505](https://gitee.com/zhu565615430/images/raw/master/CBcityimas/image-20201225142217505.png) // 6.通知代理 delegate?.pageTitleView(self, selectedIndex: currentIndex) 1234567891011回到homeVC ![image-20201225142537239](https://gitee.com/zhu565615430/images/raw/master/CBcityimas/image-20201225142537239.png)最后加上，避免循环引用加上extension遵守PageTitleViewDelegate协议![image-20201225142904333](https://gitee.com/zhu565615430/images/raw/master/CBcityimas/image-20201225142904333.png) // MARK:- 遵守PageTitleViewDelegate协议extension HomeViewController : PageTitleViewDelegate { func pageTitleView(_ titleView: PageTitleView, selectedIndex index: Int) { print(index) }} 12345运行项目 ，发现可以拿到index，控制台输出点击的序号把index传给pageContentView，添加 // MARK:- 遵守PageTitleViewDelegate协议extension HomeViewController : PageTitleViewDelegate { func pageTitleView(_ titleView: PageTitleView, selectedIndex index: Int) { pageContentView.setCurrentIndex(index)//添加此行 }} 12345回到PageTitleView VC，在下发添加对外暴露的方法![image-20210108152545633](https://gitee.com/zhu565615430/images/raw/master/CBcityimas/image-20210108152545633.png) // MARK:- 对外暴露的方法extension PageTitleView { func setTitleWithProgress(_ progress : CGFloat, sourceIndex : Int, targetIndex : Int) { // 1.取出sourceLabel/targetLabel let sourceLabel = titleLabels[sourceIndex] let targetLabel = titleLabels[targetIndex] // 2.处理滑块的逻辑 let moveTotalX = targetLabel.frame.origin.x - sourceLabel.frame.origin.x let moveX = moveTotalX * progress scrollLine.frame.origin.x = sourceLabel.frame.origin.x + moveX &#125; } 12345PageContentView里![image-20210302233328985](https://gitee.com/zhu565615430/images/raw/master/CBcityimas/image-20210302233328985.png) // MARK:- 对外暴露的方法extension PageContentView { func setCurrentIndex(_ currentIndex : Int) { let offsetX = CGFloat(currentIndex) * collectionView.frame.width collectionView.setContentOffset(CGPoint(x: offsetX, y: 0), animated: false) &#125; } 12345678910111213运行项目，点标签栏发现页面也滚动，但滑动标签未跟随滚动![Dec-25-2020 14-44-12](https://gitee.com/zhu565615430/images/raw/master/CBcityimas/Dec-25-2020%2014-44-12.gif)PageConnetView的滚动，主要是监听 ，先设置代理![image-20201225170005062](https://gitee.com/zhu565615430/images/raw/master/CBcityimas/image-20201225170005062.png) collectionView.delegate = self 1234567**遵守UICollectionViewDelegate**![image-20201225171438499](https://gitee.com/zhu565615430/images/raw/master/CBcityimas/image-20201225171438499.png) // MARK:- 遵守UICollectionViewDelegateextension PageContentView : UICollectionViewDelegate { func scrollViewDidScroll(_ scrollView: UIScrollView) &#123; print(&quot;----&quot;) &#125; } 12345678910111213手指滚动，控制台有输出，可以监测到&lt;img src=&quot;https://gitee.com/zhu565615430/images/raw/master/CBcityimas/IMG_E239AF31318F-1.jpeg&quot; alt=&quot;IMG_E239AF31318F-1&quot; style=&quot;zoom:50%;&quot; /&gt;在上方添加个属性![image-20201225175535613](https://gitee.com/zhu565615430/images/raw/master/CBcityimas/image-20201225175535613.png) private var startOffsetX : CGFloat = 0 12345继续添加扩展![image-20201225175652479](https://gitee.com/zhu565615430/images/raw/master/CBcityimas/image-20201225175652479.png) func scrollViewWillBeginDragging(_ scrollView: UIScrollView) &#123; startOffsetX = scrollView.contentOffset.x &#125; 123定义需要获取的数据 ,在**遵守UICollectionViewDataSource**的扩展下方添加扩展 // MARK:- 遵守UICollectionViewDelegateextension PageContentView : UICollectionViewDelegate { func scrollViewWillBeginDragging(_ scrollView: UIScrollView) &#123; startOffsetX = scrollView.contentOffset.x &#125; func scrollViewDidScroll(_ scrollView: UIScrollView) &#123; // 1.定义获取需要的数据 var progress : CGFloat = 0 var sourceIndex : Int = 0 var targetIndex : Int = 0 // 2.判断是左滑还是右滑 let currentOffsetX = scrollView.contentOffset.x let scrollViewW = scrollView.bounds.width if currentOffsetX &gt; startOffsetX &#123; // 左滑 // 1.计算progress progress = currentOffsetX / scrollViewW - floor(currentOffsetX / scrollViewW) // 2.计算sourceIndex sourceIndex = Int(currentOffsetX / scrollViewW) // 3.计算targetIndex targetIndex = sourceIndex + 1 if targetIndex &gt;= childVcs.count &#123; targetIndex = childVcs.count - 1 &#125; // 4.如果完全划过去 if currentOffsetX - startOffsetX == scrollViewW &#123; progress = 1 targetIndex = sourceIndex &#125; &#125; else &#123; // 右滑 // 1.计算progress progress = 1 - (currentOffsetX / scrollViewW - floor(currentOffsetX / scrollViewW)) // 2.计算targetIndex targetIndex = Int(currentOffsetX / scrollViewW) // 3.计算sourceIndex sourceIndex = targetIndex + 1 if sourceIndex &gt;= childVcs.count &#123; sourceIndex = childVcs.count - 1 &#125; &#125; // 3.将progress/sourceIndex/targetIndex传递给titleView delegate?.pageContentView(self, progress: progress, sourceIndex: sourceIndex, targetIndex: targetIndex) &#125; } 1234567到开头定义代理，将progress sourceIndex targetIndex传值给titleView![image-20201226005404473](https://gitee.com/zhu565615430/images/raw/master/CBcityimas/image-20201226005404473.png) // 定义代理，将progress sourceIndex targetIndex传值给titleViewprotocol PageContentViewDelegate : class { func pageContentView(_ contentView : PageContentView, progress : CGFloat, sourceIndex : Int, targetIndex : Int)} 12345定义代理属性，遵守协议![image-20201226005634347](https://gitee.com/zhu565615430/images/raw/master/CBcityimas/image-20201226005634347.png) weak var delegate : PageContentViewDelegate?//定义代理属性，遵守协议 12345到homeVC取值![image-20201226005821490](https://gitee.com/zhu565615430/images/raw/master/CBcityimas/image-20201226005821490.png) contentView.delegate = self//取值progress sourceIndex targetIndex 123最下方**遵守PageContentViewDelegate协议** // MARK:- 遵守PageContentViewDelegate协议extension HomeViewController : PageContentViewDelegate { func pageContentView(_ contentView: PageContentView, progress: CGFloat, sourceIndex: Int, targetIndex: Int) { pageTitleView.setTitleWithProgress(progress, sourceIndex: sourceIndex, targetIndex: targetIndex) }} 123转到PageTitleVc,在最下方添加**对外暴露的方法** // MARK:- 对外暴露的方法extension PageTitleView { func setTitleWithProgress(_ progress : CGFloat, sourceIndex : Int, targetIndex : Int) { // 1.取出sourceLabel/targetLabel let sourceLabel = titleLabels[sourceIndex] let targetLabel = titleLabels[targetIndex] // 2.处理滑块的逻辑 let moveTotalX = targetLabel.frame.origin.x - sourceLabel.frame.origin.x let moveX = moveTotalX * progress scrollLine.frame.origin.x = sourceLabel.frame.origin.x + moveX &#125; } 1234567891011运行项目，标签和下方一起滚动，但是字体颜色没有变化![Dec-26-2020 01-24-33](https://gitee.com/zhu565615430/images/raw/master/CBcityimas/Dec-26-2020%2001-24-33.gif)颜色的渐变在PageTitleView.swift，定义RGB值常量![image-20201226114737491](https://gitee.com/zhu565615430/images/raw/master/CBcityimas/image-20201226114737491.png) private let kNormalColor : (CGFloat, CGFloat, CGFloat) = (85, 85, 85)private let kSelectColor : (CGFloat, CGFloat, CGFloat) = (255, 128, 0) 123456789 修改设置的颜色用RGB值设置![image-20201226115501235](https://gitee.com/zhu565615430/images/raw/master/CBcityimas/image-20201226115501235.png)![image-20201226115628756](https://gitee.com/zhu565615430/images/raw/master/CBcityimas/image-20201226115628756.png)![image-20201226115723314](https://gitee.com/zhu565615430/images/raw/master/CBcityimas/image-20201226115723314.png) label.textColor = UIColor(r: kNormalColor.0, g: kNormalColor.1, b: kNormalColor.2)//文字颜色 firstLabel.textColor = UIColor(r: kSelectColor.0, g: kSelectColor.1, b: kSelectColor.2) currentLabel.textColor = UIColor(r: kSelectColor.0, g: kSelectColor.1, b: kSelectColor.2) oldLabel.textColor = UIColor(r: kNormalColor.0, g: kNormalColor.1, b: kNormalColor.2) 12345颜色的渐变![image-20201226165046797](https://gitee.com/zhu565615430/images/raw/master/CBcityimas/image-20201226165046797.png) // 3.颜色的渐变(复杂) // 3.1.取出变化的范围 let colorDelta = (kSelectColor.0 - kNormalColor.0, kSelectColor.1 - kNormalColor.1, kSelectColor.2 - kNormalColor.2) // 3.2.变化sourceLabel sourceLabel.textColor = UIColor(r: kSelectColor.0 - colorDelta.0 * progress, g: kSelectColor.1 - colorDelta.1 * progress, b: kSelectColor.2 - colorDelta.2 * progress) // 3.2.变化targetLabel targetLabel.textColor = UIColor(r: kNormalColor.0 + colorDelta.0 * progress, g: kNormalColor.1 + colorDelta.1 * progress, b: kNormalColor.2 + colorDelta.2 * progress) // 4.记录最新的index currentIndex = targetIndex 1234567891011运行程序，轻微滑动，有颜色渐变的效果&lt;img src=&quot;https://gitee.com/zhu565615430/images/raw/master/CBcityimas/May-27-2021%2016-19-07.gif&quot; alt=&quot;May-27-2021 16-19-07&quot; style=&quot;zoom:50%;&quot; /&gt;对点击事件的优化pageContentV去定义属性![image-20201226165741879](https://gitee.com/zhu565615430/images/raw/master/CBcityimas/image-20201226165741879.png) private var isForbidScrollDelegate : Bool = false 12345记录要禁止执行的代理方法![image-20201226170139718](https://gitee.com/zhu565615430/images/raw/master/CBcityimas/image-20201226170139718.png) // 1.记录需要禁止执行代理方法 isForbidScrollDelegate = true 123![image-20201226170634281](https://gitee.com/zhu565615430/images/raw/master/CBcityimas/image-20201226170634281.png) isForbidScrollDelegate = false // 0.判断是否是点击事件 if isForbidScrollDelegate &#123; return &#125; 主界面导航栏内容滚动与点击的布局完成 &lt;img src=&quot;https://gitee.com/zhu565615430/images/raw/master/CBcityimas/May-27-2021%2016-20-47.gif&quot; alt=&quot;May-27-2021 16-20-47&quot; style=&quot;zoom:50%;&quot; /&gt;","categories":[],"tags":[]},{"title":"斗鱼直播Demo(一)","slug":"斗鱼直播Demo","date":"2020-05-16T05:49:59.000Z","updated":"2020-12-30T06:49:00.000Z","comments":true,"path":"2020/05/16/斗鱼直播Demo/","link":"","permalink":"http://example.com/2020/05/16/%E6%96%97%E9%B1%BC%E7%9B%B4%E6%92%ADDemo/","excerpt":"","text":"项目开始（主框架搭建） 导入图片，设置启动图片，App图标导入启动图片，项目图标，并给项目做好文档管理 视图控制器的设置在项目里设置，设置默认启动控制器为main，添加别的视图控制器 添加UITab Bar Controller视图控制器，然后分别选择两个视图控制器，分别为其添加Navigation Controller（导航控制器）。 复制两个一样的，一个四个，并连接 分别修改item名称，首页、关注、直播、我的，然后添加tabbar图片到Assets.在分别设置好每个的图片 修复黑屏 修改TABbar图标为橙色的代码，在AppDelegate下添加1UITabBar.appearance().tintColor = UIColor.orange 视图太多，容易混乱。新建home故事版，如下图 将各个功能模块拆分出来 ，并且放入自己模块中 为了适配低版本，删连线，用代码方式连接 新建视图控制器MainViewController，继承自UITabBarController，然后到故事版将class修改MainViewController（图略） 给MainViewController添加新的方法，全部代码如下，这样就获取得子控制器 123456789101112131415161718192021222324import UIKitclass MainViewController: UITabBarController &#123; override func viewDidLoad() &#123; super.viewDidLoad() addChildVc(StoryName: &quot;Home&quot;) addChildVc(StoryName: &quot;Live&quot;) addChildVc(StoryName: &quot;Follow&quot;) addChildVc(StoryName: &quot;Profile&quot;) &#125; private func addChildVc(StoryName: String) &#123; // 1.通过Storyboard获取控制器 let ChildVc = UIStoryboard(name: StoryName, bundle: nil).instantiateInitialViewController()! // 2.将childVC作为子控制器 addChild(ChildVc) &#125;&#125; 设置布局首页搭建对模块进行mvc的划分，在fider添加M、V、C文件夹,拉到项目里 创建单独的控制器来管理它，将class修改HomeViewController（图略）cocoa 添加extension,抽取方法调用 12345678910111213 override func viewDidLoad() &#123; super.viewDidLoad() SetupUI() &#125;&#125;// Mark:-设置UI界面extension HomeViewController &#123; private func SetupUI() &#123; &#125;&#125; 导航栏的设置左侧导航栏添加左侧导航栏的方法，因为button有点击变灰，我们要自定义customView，不能使用一张图片上去 继续在SetupUI方法下面添加代码，并且在SetupUI方法中调用 1234567891011private func setupNavigationBar()&#123; let btn = UIButton() btn.setImage(UIImage(named: &quot;logo&quot;), for: .normal) btn.sizeToFit() //根据图片大小自适应 navigationItem.leftBarButtonItem = UIBarButtonItem(customView: btn)//customView自定义button &#125;&#125; 右侧导航栏 1.搜索历史Item点进去有高亮的效果，要设置两个图标，所以用自定义customView，继续在下方添加代码 出现问题，3个图标太近，需要设置sizeToFit，添加 1let size = CGSize(width: 40, height: 40) 修改代码 1btn.sizeToFit() //根据图片大小自适应 为 1historyBtn.frame = CGRect(origin: CGPoint.zero, size: size) //根据图片大小自适应 添加的代码如下 12345678910111213141516171819let size = CGSize(width: 40, height: 40)let historyBtn = UIButton()historyBtn.setImage(UIImage(named: &quot;image_my_history&quot;), for: .normal)//正常historyBtn.setImage(UIImage(named: &quot;Image_my_history_click&quot;), for: .highlighted)//高亮historyBtn.frame = CGRect(origin: CGPoint.zero, size: size) //根据图片大小自适应let historyItem = UIBarButtonItem(customView: historyBtn) //搜索历史Itemlet searchIBtn = UIButton()searchIBtn.setImage(UIImage(named: &quot;btn_search&quot;), for: .normal)//正常searchIBtn.setImage(UIImage(named: &quot;btn_search_clicked&quot;), for: .highlighted)//高亮searchIBtn.frame = CGRect(origin: CGPoint.zero, size: size) //根据图片大小自适应let searchItem = UIBarButtonItem(customView: searchIBtn) //搜索Itemlet qrcodeBtn = UIButton()qrcodeBtn.setImage(UIImage(named: &quot;Image_scan&quot;), for: .normal)//正常qrcodeBtn.setImage(UIImage(named: &quot;Image_scan_click&quot;), for: .highlighted)//高亮qrcodeBtn.frame = CGRect(origin: CGPoint.zero, size: size) //根据图片大小自适应let qrcodeItem = UIBarButtonItem(customView: qrcodeBtn ) //二维码ItemnavigationItem.rightBarButtonItems = [historyItem, searchItem, qrcodeItem]//设置数组 修改后Item，距离变大了 对系统类进行扩展 以上发现代码重复太多，需要抽取，扩展，在Tools在Fidder打开新建Extension，拖到项目Tools，创建个UIBarButtonItem-Extension.swift 纯swift文件的扩展 添加如下代码 12345678extension UIBarButtonItem &#123; class func createItem(ImageName : String, highImageName : String, size : CGSize) -&gt; UIBarButtonItem &#123; let btn = UIButton() btn.setImage(UIImage(named: ImageName), for: .normal) btn.setImage(UIImage(named: ImageName), for: .highlighted) btn.frame = CGRect(origin: CGPoint.zero, size: size) return UIBarButtonItem(customView: btn) &#125; 修改HomeVC代码，删掉不需要的，修改后： 1234567// 2.设置右侧导航栏 let size = CGSize(width: 40, height: 40) let historyItem = UIBarButtonItem.createItem(ImageName: &quot;image_my_history&quot;, highImageName: &quot;Image_my_history_click&quot;, size:size)//搜索历史Item let searchItem = UIBarButtonItem.createItem(ImageName: &quot;btn_search&quot;, highImageName: &quot;btn_search_clicked&quot;, size: size) //搜索Item let qrcodeItem = UIBarButtonItem.createItem(ImageName: &quot;Image_scan&quot;, highImageName: &quot;Image_scan_click&quot;, size: size) //二维码Item navigationItem.rightBarButtonItems = [historyItem, searchItem, qrcodeItem]//设置数组 以上是类方法，但不太好，我们 改用构造函数init()，构造函数不需要写返回值修改UIBarButtonItem-Extension.swift 代码 12345678convenience init(ImageName : String, highImageName : String, size : CGSize) &#123; let btn = UIButton() btn.setImage(UIImage(named: ImageName), for: .normal) btn.setImage(UIImage(named: ImageName), for: .highlighted) btn.frame = CGRect(origin: CGPoint.zero, size: size) self.init(customView : btn)&#125; 修改HomeVC如下 12345678let size = CGSize(width: 40, height: 40)let historyItem = UIBarButtonItem(ImageName: &quot;image_my_history&quot;, highImageName: &quot;Image_my_history_click&quot;, size: size)//搜索历史Itemlet searchItem = UIBarButtonItem(ImageName: &quot;btn_search&quot;, highImageName: &quot;btn_search_clicked&quot;, size: size)//搜索Itemlet qrcodeItem = UIBarButtonItem(ImageName: &quot;Image_scan&quot;, highImageName: &quot;Image_scan_click&quot;, size: size)//二维码ItemnavigationItem.rightBarButtonItems = [historyItem, searchItem, qrcodeItem]//设置数组 同时把左侧的也抽取进行 因为只需要传一个logo,可以使用默认参数 UIBarButtonItem-Extension.swift 里 1convenience init(ImageName : String, highImageName : String = &quot;&quot;, size : CGSize = CGSize.zero) 添加条件语句 12345678910111213141516171819202122 convenience init(ImageName : String, highImageName : String = &quot;&quot;, size : CGSize = CGSize.zero) &#123; //1.创建UIButton let btn = UIButton() btn.setImage(UIImage(named: ImageName), for: .normal) //2.设置btn图片 if highImageName != &quot;&quot; &#123; btn.setImage(UIImage(named: ImageName), for: .highlighted) &#125; //3.设置btn尺寸 if size == CGSize.zero &#123; btn.sizeToFit() &#125; else &#123; btn.frame = CGRect(origin: CGPoint.zero, size: size) &#125; //4.创建UIbarbuttonItem self.init(customView : btn) &#125;&#125; 同时修改home VC代码后前对比 导航栏的总结在扩展里UIBarButtonItem-Extension使用构造函数init12345678910111213141516171819202122import UIKitextension UIBarButtonItem &#123; // 便利构造函数: 1&gt; convenience开头 2&gt; 在构造函数中必须明确调用一个设计的构造函数(self) convenience init(ImageName : String, highImageName : String = &quot;&quot;, size : CGSize = CGSize.zero) &#123; //1.创建UIButton let btn = UIButton() btn.setImage(UIImage(named: ImageName), for: .normal) //2.设置btn图片 if highImageName != &quot;&quot; &#123; btn.setImage(UIImage(named: ImageName), for: .highlighted) &#125; //3.设置btn尺寸 if size == CGSize.zero &#123; btn.sizeToFit() &#125; else &#123; btn.frame = CGRect(origin: CGPoint.zero, size: size) &#125; //4.创建UIbarbuttonItem self.init(customView : btn) &#125;&#125; 在视图控制器处，设置导航栏添加extension然后分别设置左右导航栏样式,设置数组，给其添加上 123456789101112131415161718192021// Mark:-设置UI界面extension HomeViewController &#123; private func SetupUI() &#123;// 1.设置导航栏 setupNavigationBar() &#125; private func setupNavigationBar()&#123;// 1.设置左侧导航栏 navigationItem.leftBarButtonItem = UIBarButtonItem(ImageName:&quot;logo&quot; )//customView自定义button // 2.设置右侧导航栏 let size = CGSize(width: 40, height: 40) let historyItem = UIBarButtonItem(ImageName: &quot;image_my_history&quot;, highImageName: &quot;Image_my_history_click&quot;, size: size)//搜索历史Item let searchItem = UIBarButtonItem(ImageName: &quot;btn_search&quot;, highImageName: &quot;btn_search_clicked&quot;, size: size)//搜索Item let qrcodeItem = UIBarButtonItem(ImageName: &quot;Image_scan&quot;, highImageName: &quot;Image_scan_click&quot;, size: size)//二维码Item navigationItem.rightBarButtonItems = [historyItem, searchItem, qrcodeItem]//设置数组 &#125; &#125; 首页框架搭建对标题栏与下方内容进行封装 标题栏的封装 标题栏用lable来做，监听手势点击，内容用UIconnetionView进行封装， 封装PageTitleView（标签栏） 在view新建PageTitleView.swift 封装构造函数，让别人在创建对象时，就传入真实需要显示的内容 frame：创建对象时确定了frame就可以直接设置子控件的位置和尺寸 titles：显示的所有标题 抽取常量在Extension新建Common.swift，并修改为以下代码 12345import UIKitlet KStatusBarH: CGFloat = 20 //状态栏高度let kNavigationBarH: CGFloat = 44let kScreenW = UIScreen.main.bounds.width//屏幕的宽度let kScreenH = UIScreen.main.bounds.height//屏幕的高度 在homevc添加代码，并添加到视图界面 主要添加代码如下 12345678910 private let KTitleViewH : CGFloat = 40 //屏幕高度40// Mark:-懒加载属性 private lazy var pageTitleView : PageTitleView = &#123; let titleFrame = CGRect(x: 0, y:KStatusBarH + kNavigationBarH , width:kScreenW, height: KTitleViewH)//导航栏位置的设置 let titles = [&quot;推荐&quot;,&quot;游戏&quot;,&quot;娱乐&quot;,&quot;趣玩&quot;] let titleView = PageTitleView(frame: titleFrame, titles: titles) titleView.backgroundColor = UIColor.purple return titleView &#125;() 1view.addSubview(pageTitleView) 添加UIscrollView在PageTitleView.swift，添加scrollView懒加载，然后添加到视图 12345678// MARk: - 懒加载属性 private lazy var scrollView : UIScrollView = &#123; let scrollView = UIScrollView() scrollView.showsHorizontalScrollIndicator = false scrollView.scrollsToTop = false scrollView.bounces = false return scrollView &#125;() 12345678910// MARk: - 设置UI界面extension PageTitleView &#123; private func setupUI() &#123;// 1.添加UIscrollView addSubview(scrollView) scrollView.frame = bounds// 2.添加title对应的label setupTitleLabels() &#125;&#125; lable的设置，继续添加代码 代码如下： 1private let kScrollLineH : CGFloat = 2 //滚动条高度 123456789101112131415161718192021222324252627private func setupTitleLabels() &#123; for (index, title) in titles.enumerated() &#123; // 0.确定label的一些frame的值 let labelW : CGFloat = frame.width / CGFloat(titles.count) let labelH : CGFloat = frame.height - kScrollLineH let labelY : CGFloat = 0 // 1.创建UILabel let label = UILabel() // 2.设置Label的属性 label.text = title label.tag = index label.font = UIFont.systemFont(ofSize: 16.0)//默认字体大小17 label.textColor = UIColor.darkGray//默认文字颜色 label.textAlignment = .center // 3.设置label的frame let labelX : CGFloat = labelW * CGFloat(index) label.frame = CGRect(x: labelX, y: labelY, width: labelW, height: labelH) // 4.将label添加到scrollView中 scrollView.addSubview(label) &#125; &#125; 回调home VC，不需要调整UIScrollView的内边距 1automaticallyAdjustsScrollViewInsets = **false** PageTitleView.swift里添加 setupUI()到构造函数内 12345678// MARk: - 自定义构造函数init(frame: CGRect, titles : [String]) &#123; self.titles = titles super.init(frame: frame) // 设置UI界面 setupUI() //----------添加此行 运行项目 在homeVC删掉 ，去掉紫色 加滚动条和底部的线PageTitleView 懒加载创建滚动条，创建个UIlable的数组 接着把lable添加到数组里面 设置底线和滚动滑块 1234567891011// MARk: - 设置UI界面extension PageTitleView &#123; private func setupUI() &#123;// 1.添加UIscrollView addSubview(scrollView) scrollView.frame = bounds// 2.添加title对应的label setupTitleLabels() // 3.设置底线和滚动的滑块 setupBottomLineAndScrollLine() &#125; 添加UIScrollView ，加scrollLine方法，setupBottomLineAndScrollLine方法 把字体的颜色也和下方一样 运行效果 用的代码如下 1private lazy var titleLabels : [UILabel] = [UILabel]() 12345private lazy var scrollLine : UIView = &#123; let scrollLine = UIView() scrollLine.backgroundColor = UIColor.orange return scrollLine&#125;() 12345678910111213141516fileprivate func setupBottomLineAndScrollLine() &#123; // 1.添加底线 let bottomLine = UIView() bottomLine.backgroundColor = UIColor.lightGray//颜色 let lineH : CGFloat = 0.5 bottomLine.frame = CGRect(x: 0, y: frame.height - lineH, width: frame.width, height: lineH) addSubview(bottomLine) // 2.添加scrollLine // 2.1.获取第一个Label guard let firstLabel = titleLabels.first else &#123; return &#125; firstLabel.textColor = UIColor.orange // 把字体的颜色也和下方一样 // 2.2.设置scrollLine的属性 scrollView.addSubview(scrollLine) scrollLine.frame = CGRect(x: firstLabel.frame.origin.x, y: frame.height - kScrollLineH, width: firstLabel.frame.width, height: kScrollLineH)&#125;","categories":[],"tags":[]},{"title":"Runtime消息发送机制","slug":"iOS调用一个方法时","date":"2020-04-22T04:49:00.000Z","updated":"2020-04-22T06:49:00.000Z","comments":true,"path":"2020/04/22/iOS调用一个方法时/","link":"","permalink":"http://example.com/2020/04/22/iOS%E8%B0%83%E7%94%A8%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%E6%97%B6/","excerpt":"","text":"Runtime消息发送机制1）iOS调用一个方法时，实际上会调用objc_msgSend(receiver, selector, arg1, arg2, …)，该方法第一个参数是消息接收者，第二个参数是方法名，剩下的参数是方法参数；2）iOS调用一个方法时，会先去该类的方法缓存列表里面查找是否有该方法，如果有直接调用，否则走第3）步；3）去该类的方法列表里面找，找到直接调用，把方法加入缓存列表；否则走第4）步；4）沿着该类的继承链继续查找，找到直接调用，把方法加入缓存列表；否则消息转发流程； 如下图：","categories":[],"tags":[]},{"title":"YYModel不能读取model类属性变量无法解析返回空解决","slug":"创建Model类时属性变量前需加-objc","date":"2020-03-14T05:45:45.000Z","updated":"2020-03-14T06:49:00.000Z","comments":true,"path":"2020/03/14/创建Model类时属性变量前需加-objc/","link":"","permalink":"http://example.com/2020/03/14/%E5%88%9B%E5%BB%BAModel%E7%B1%BB%E6%97%B6%E5%B1%9E%E6%80%A7%E5%8F%98%E9%87%8F%E5%89%8D%E9%9C%80%E5%8A%A0-objc/","excerpt":"","text":"使用 Swift 创建Model类时属性变量前需加@objc ，否则 YYModel 将不能读取 model 类属性变量，即无法解析返回空。","categories":[],"tags":[]},{"title":"Swift闭包的参数改变","slug":"Swift闭包的参数改变","date":"2020-02-14T05:49:59.000Z","updated":"2020-02-14T06:49:00.000Z","comments":true,"path":"2020/02/14/Swift闭包的参数改变/","link":"","permalink":"http://example.com/2020/02/14/Swift%E9%97%AD%E5%8C%85%E7%9A%84%E5%8F%82%E6%95%B0%E6%94%B9%E5%8F%98/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"swiftui初探（5）","slug":"swiftui初探（5）","date":"2020-01-20T04:49:00.000Z","updated":"2021-02-22T06:49:00.000Z","comments":true,"path":"2020/01/20/swiftui初探（5）/","link":"","permalink":"http://example.com/2020/01/20/swiftui%E5%88%9D%E6%8E%A2%EF%BC%885%EF%BC%89/","excerpt":"","text":"窗体和控制新建Settings(SwiftUiView),为其设计样式 12345678910111213141516171819202122232425262728struct Settings: View &#123; @State var reeive = false @State var number = 1 @State var selection = 1 @State var date = Date() var body: some View &#123; NavigationView &#123; Form &#123; Toggle(isOn: $reeive) &#123; Text(&quot;接收通知&quot;) &#125; Stepper(value: $number, in: 1...10) &#123; Text(&quot;\\(number) Notification\\(number &gt; 1 ? &quot;s&quot; : &quot;&quot;) per week&quot;) &#125; Picker(selection: $selection, label: Text(&quot;最喜欢的课程&quot;)) &#123; Text(&quot;SwiftUI&quot;).tag(1) Text(&quot;React&quot;).tag(2) &#125; DatePicker(selection: $date, label: &#123; Text(&quot;日期&quot;) &#125;) &#125; .navigationBarTitle(&quot;设置&quot;) &#125; &#125;&#125; 添加你的邮件标签 12345@State var email = &quot;&quot;TextField(&quot;你的邮件&quot;, text: $email) .textFieldStyle(RoundedBorderTextFieldStyle()) TextField inside HStack然后改为Section，添加提交按钮 将设置添加到TabBar中 修复左侧按钮 滚动动画CourseView inside HStack然后改为GeometryReader 设置卡片动画并添加几张卡片 新建CertificateRows(SwiftUiView),为其设计样式 12345678910111213141516171819202122232425262728import SwiftUIstruct CertificateRows: View &#123; var body: some View &#123; CertificateView() &#125;&#125;struct CertificateRows_Previews: PreviewProvider &#123; static var previews: some View &#123; CertificateRows() &#125;&#125;struct Certificate: Identifiable &#123; var id = UUID() var title: String var image: String var width: CGFloat var height: CGFloat&#125;let certificateData = [ Certificate(title: &quot;OC&quot;, image: &quot;Certificate1&quot;, width: 230, height: 150), Certificate(title: &quot;Swift&quot;, image: &quot;Certificate2&quot;, width: 230, height: 150), Certificate(title: &quot;Java&quot;, image: &quot;Certificate3&quot;, width: 230, height: 150), Certificate(title: &quot;GO&quot;, image: &quot;Certificate4&quot;, width: 230, height: 150),] 设置数据，循环出现 回去绑定数据 设置卡片内图片大小 修改卡片样式，添加滚动视图 到HomeList，把滚动视图添加上，调整下布局 调整卡片布局 iPad与小屏幕适配 按钮颜色适配与侧边栏 顶部遮挡适配 12let statusBarHeight = UIApplication.shared.windows[0].windowScene?.statusBarManager?.statusBarFrame.height ?? 0let screen = UIScreen.main.bounds 修复铃声按钮打开是更新 12345678910 @State var showUpdate = falseButton(action: &#123; self.showUpdate.toggle() &#125;) &#123; CircleButton(icon: &quot;bell&quot;) &#125;.sheet(isPresented: $showUpdate) &#123; UpdateList() &#125; 左侧设置按钮的设置 123456789101112131415161718.foregroundColor(.primary)@State var showUpdate = false if (item.title == &quot;设置&quot;) &#123; Button(action: &#123; self.showUpdate.toggle() &#125;) &#123; MenuRow(image: item.icon, text: item.title) &#125;.sheet(isPresented: self.$showUpdate) &#123; Settings() &#125; &#125; else &#123; MenuRow(image: item.icon, text: item.title) &#125; 修改主页为home","categories":[],"tags":[]},{"title":"swiftui初探（4）","slug":"swiftui初探（4）","date":"2020-01-19T04:49:00.000Z","updated":"2021-02-22T06:49:00.000Z","comments":true,"path":"2020/01/19/swiftui初探（4）/","link":"","permalink":"http://example.com/2020/01/19/swiftui%E5%88%9D%E6%8E%A2%EF%BC%884%EF%BC%89/","excerpt":"","text":"导航和传递数据VStack inside HStack 显示添加图片 123456Image(item.image) .resizable() .aspectRatio(contentMode: .fit)//图片设置自适应不改变长款 .frame(width: 80, height: 80) .background(Color(&quot;background&quot;)) .cornerRadius(20) 新建UpdateDetail(SwiftUiView),为其设计样式 1234567891011121314151617181920212223struct UpdateDetail: View &#123; var title = &quot;Swiftui&quot; var text = &quot;Loading&quot; var image = &quot;Illustration1&quot; var body: some View &#123; VStack(spacing: 20.0) &#123; Text(title) .font(.largeTitle) .fontWeight(.heavy) Image(image) .resizable() .aspectRatio(contentMode: .fit) .frame(height: 200) Text(text) .lineLimit(nil) Spacer() &#125; .padding(30.0) &#125;&#125; 回到UpdateList，添加视图到点击 1NavigationLink(destination: UpdateDetail(title: item.title, text: item.text, image: item.image)) 调整文字适应对齐 12.frame(minWidth: 0, maxWidth: .infinity, alignment: .leading) 合并和编辑数据新建UpdateStore(SwiftUiView),为其设计样式123456789101112131415import SwiftUIimport Combineclass UpdateStore: ObservableObject &#123; let didChange = PassthroughSubject&lt;Void, Never&gt;() @Published var updates: [Update] &#123; didSet &#123; didChange.send() &#125; &#125; init(updates: [Update] = []) &#123; self.updates = updates &#125;&#125; 1@ObservedObject var store = UpdateStore(updates: updateData)// 声明 UpdateStore 类对象 新建一个按钮，方便添加数据List inside VStack 1234567func addUpdate() &#123; store.updates.append(Update(image: &quot;Illustration1&quot;, title: &quot;落梅&quot;, text: &quot;这个女子，曾经走过人间四月，又与连开的夏季有过相濡以沫的约定&quot;, date: &quot;JUN 1&quot;))&#125; Button(action: addUpdate) &#123; Text(&quot;添加&quot;) &#125; 修改下布局 添加删除按钮添加删除后排序方法与编辑按钮 123func move(from source: IndexSet, to destination: Int) &#123; store.updates.swapAt(source.first!, destination)&#125; 给按钮添加样式 标签栏与测试新建TabBar(SwiftUiView),为其设计样式 1234567891011121314151617181920212223242526272829struct TabBar: View &#123; @State var selectedView = 1 var body: some View &#123; TabView(selection: .constant(1)) &#123; Home().tabItem &#123; VStack &#123; Image(&quot;IconHome&quot;) Text(&quot;首页&quot;) &#125; &#125; .tag(1) ContentView().tabItem &#123; VStack &#123; Image(&quot;IconCards&quot;) Text(&quot;证书&quot;) &#125; &#125; .tag(2) UpdateList().tabItem &#123; VStack &#123; Image(&quot;IconSettings&quot;) Text(&quot;最新&quot;) &#125; &#125; .tag(3) &#125; &#125;&#125; 修改模拟器首页视图 暗黑模式和辅助功能（无障碍模式） 1234BlurView(style: .systemThinMaterial).environment(\\.colorScheme, .dark).environment(\\.sizeCategory, .extraExtraLarge) TabBar() inside HStack","categories":[],"tags":[]},{"title":"swiftui初探（3）","slug":"swiftui初探（3）","date":"2020-01-18T04:49:00.000Z","updated":"2021-02-22T06:49:00.000Z","comments":true,"path":"2020/01/18/swiftui初探（3）/","link":"","permalink":"http://example.com/2020/01/18/swiftui%E5%88%9D%E6%8E%A2%EF%BC%883%EF%BC%89/","excerpt":"","text":"滚动视图新建HomeList.swift(SwiftUiView),为其设计卡片样式 123456789101112131415161718 var body: some View &#123; VStack(alignment: .leading) &#123; Text(&quot;设计一个应用非常棒&quot;) .font(/*@START_MENU_TOKEN@*/.title/*@END_MENU_TOKEN@*/) .fontWeight(/*@START_MENU_TOKEN@*/.bold/*@END_MENU_TOKEN@*/) .foregroundColor(Color.white) .padding(20) .lineLimit(4) .frame(width: 150) Spacer() Image(&quot;Illustration1&quot;) &#125; .background(Color(&quot;background3&quot;)) .cornerRadius(30) .frame(width: 246, height: 360) .shadow(color: Color(red: 0.27058823529411763, green: 0.23529411764705882, blue: 0.788235294117647, opacity: 0.3), radius: 20, x: 0, y: 20) &#125;&#125; 将颜色3和颜色4复制处理为背景3和背景4，不透明30 点击VStack,选择in HStack，然后提取子视图，点击VStack，subView为CourseView（） 点击VStack,选择repeat,重复3次 点击HStack,选择Group，改为ScrollView 滚动视图的设置 模态 12345678910111213141516@State var showContentView: Bool = falsevar body: some View &#123; ScrollView(.horizontal, showsIndicators: false) &#123; VStack &#123; HStack &#123; ForEach(0 ..&lt; 3) &#123; item in Button(action: &#123; self.showContentView = true &#125;) &#123; CourseView() &#125;.sheet(isPresented: self.$showContentView) &#123; ContentView() &#125; &#125; &#125; &#125; 创建数据模型 123456789101112131415161718192021struct Courses: Identifiable &#123; var id = UUID() var title : String var image : String var backgroundColor: Color var shadowColor : Color&#125;let CourseData = [ Courses( title: &quot;设计一个非常棒应用&quot;, image: &quot;Illustration1&quot;, backgroundColor: Color(&quot;background3&quot;), shadowColor: Color(&quot;backgroundShadow3&quot;) ), Courses( title: &quot;课程设计&quot;, image: &quot;Illustration2&quot;, backgroundColor: Color(&quot;background4&quot;), shadowColor: Color(&quot;backgroundShadow4&quot;) )] 使用数据模型 绑定数据模型 123456 var title = &quot;设计一个非常棒应用&quot; var image : String = &quot;Illustration1&quot; var color = Color(&quot;background3&quot;) var shadowColor = Color(&quot;backgroundshadow3&quot;) CourseView(title: item.title, image: item.image, color: item.backgroundColor, shadowColor: item.shadowColor) 调整页面大小，调整文字大小一样适应 调整设计间距 模糊背景新建BlurView.swift(SwiftUiView),为其设计样式 1234567891011121314151617181920212223struct BlurView: UIViewRepresentable &#123; let style: UIBlurEffect.Style func makeUIView(context: UIViewRepresentableContext&lt;BlurView&gt;) -&gt; UIView &#123; let view = UIView(frame: .zero) view.backgroundColor = .clear let blurEffect = UIBlurEffect(style: style) let blurView = UIVisualEffectView(effect: blurEffect) blurView.translatesAutoresizingMaskIntoConstraints = false view.insertSubview(blurView, at: 0) NSLayoutConstraint.activate([ blurView.heightAnchor.constraint(equalTo: view.heightAnchor), blurView.widthAnchor.constraint(equalTo: view.widthAnchor) ]) return view &#125; func updateUIView(_ uiView: UIView, context: UIViewRepresentableContext&lt;BlurView&gt;) &#123; &#125; &#125; 回到ContentView中，使用模糊背景 回到ContentView中，将HomeList视图添加上去 重新设计布局标题在滚动视图之上 回到HomeList中，修改视图 添加模糊与动画效果 导航视图和列表新建UpdateList.swift(SwiftUiView),为其设计样式从工具栏添加一个NavigationView， 123456789101112131415161718192021 @State var present = false var body: some View &#123; NavigationView &#123; List(0 ..&lt; 20) &#123; item in NavigationLink(destination: Text(&quot;1&quot;)) &#123; Text(&quot;Navigate 1&quot;) &#125; &#125; .navigationBarTitle(Text(&quot;更新&quot;)) .navigationBarItems(trailing: Button(action: &#123; self.present.toggle() &#125;) &#123; Image(systemName: &quot;gear&quot;) &#125; .sheet(isPresented: $present, content: &#123; Text(&quot;Settings&quot;) &#125;) ) &#125; &#125;&#125; 在底部创建数据模型123456789101112131415161718struct Update: Identifiable &#123; var id = UUID() var image: String var title: String var text: String var date: String&#125;let updateDate = [ Update(image: &quot;Illustration1&quot;, title: &quot;swiftui&quot;, text: &quot;大家忽视覅偶尔回复而韩国is的hi多少个is多个收到货IGis个his读后感is多个hi韩国ID深V出魔抗VBUI欧盟是的归属感就是 属地化工is多个hi是个 是个hi第三帝国会死哦低功耗is电话公司工会&quot;, date: &quot;JUN 26&quot;), Update(image: &quot;Illustration2&quot;, title: &quot;swiftui&quot;, text: &quot;大家忽视覅偶尔回复而韩国is的hi多少个is多个收到货IGis个his读后感is多个hi韩国ID深V出魔抗VBUI欧盟是的归属感就是 属地化工is多个hi是个 是个hi第三帝国会死哦低功耗is电话公司工会&quot;, date: &quot;JUN 26&quot;), Update(image: &quot;Illustration3&quot;, title: &quot;swiftui&quot;, text: &quot;大家忽视覅偶尔回复而韩国is的hi多少个is多个收到货IGis个his读后感is多个hi韩国ID深V出魔抗VBUI欧盟是的归属感就是 属地化工is多个hi是个 是个hi第三帝国会死哦低功耗is电话公司工会&quot;, date: &quot;JUN 26&quot;), Update(image: &quot;Illustration4&quot;, title: &quot;swiftui&quot;, text: &quot;大家忽视覅偶尔回复而韩国is的hi多少个is多个收到货IGis个his读后感is多个hi韩国ID深V出魔抗VBUI欧盟是的归属感就是 属地化工is多个hi是个 是个hi第三帝国会死哦低功耗is电话公司工会&quot;, date: &quot;JUN 26&quot;), Update(image: &quot;Certificate1&quot;, title: &quot;swiftui&quot;, text: &quot;大家忽视覅偶尔回复而韩国is的hi多少个is多个收到货IGis个his读后感is多个hi韩国ID深V出魔抗VBUI欧盟是的归属感就是 属地化工is多个hi是个 是个hi第三帝国会死哦低功耗is电话公司工会&quot;, date: &quot;JUN 26&quot;), Update(image: &quot;Certificate2&quot;, title: &quot;swiftui&quot;, text: &quot;大家忽视覅偶尔回复而韩国is的hi多少个is多个收到货IGis个his读后感is多个hi韩国ID深V出魔抗VBUI欧盟是的归属感就是 属地化工is多个hi是个 是个hi第三帝国会死哦低功耗is电话公司工会&quot;, date: &quot;JUN 26&quot;), Update(image: &quot;Certificate3&quot;, title: &quot;swiftui&quot;, text: &quot;大家忽视覅偶尔回复而韩国is的hi多少个is多个收到货IGis个his读后感is多个hi韩国ID深V出魔抗VBUI欧盟是的归属感就是 属地化工is多个hi是个 是个hi第三帝国会死哦低功耗is电话公司工会&quot;, date: &quot;JUN 26&quot;),] 显示数据 12345678910111213141516171819202122232425var updates = updateDate@State var present = falsevar body: some View &#123; NavigationView &#123; List(updates) &#123; item in NavigationLink(destination: Text(&quot;1&quot;)) &#123; VStack(alignment: .leading) &#123; Text(item.title) .font(.headline) Text(item.text) .lineLimit(/*@START_MENU_TOKEN@*/2/*@END_MENU_TOKEN@*/) .lineSpacing(4) .font(.subheadline) .frame(height: 50.0) Text(item.date) .font(.caption) .fontWeight(.bold) .foregroundColor(Color.gray) &#125; &#125;","categories":[],"tags":[]},{"title":"swiftui初探（2）","slug":"swiftui初探（2）","date":"2020-01-17T04:49:00.000Z","updated":"2020-01-18T06:49:00.000Z","comments":true,"path":"2020/01/17/swiftui初探（2）/","link":"","permalink":"http://example.com/2020/01/17/swiftui%E5%88%9D%E6%8E%A2%EF%BC%882%EF%BC%89/","excerpt":"","text":"创建侧边菜单栏新建Home（SwiftUIView），添加我的账户标题与图片 12345678910111213 VStack &#123; HStack &#123; Image(systemName: &quot;creditcard&quot;) .imageScale(.large) .foregroundColor(Color(&quot;icons&quot;)) .frame(width: 32, height: 32) Text(&quot;我的账户&quot;) .font(.headline) &#125; &#125; &#125;&#125; 添加完整四个标签 1234567891011121314151617181920212223242526272829303132333435import SwiftUIstruct Home: View &#123; var body: some View &#123; VStack(alignment: .leading) &#123; MenuRow(image: &quot;person.crop.circle&quot;, text: &quot;我的账户&quot;) MenuRow(image: &quot;creditcard&quot;, text: &quot;记账&quot;) MenuRow(image: &quot;person.and.person&quot;, text: &quot;团队&quot;) MenuRow(image: &quot;arrow.uturn.down&quot;, text: &quot;退出&quot;) &#125; &#125;&#125;struct Home_Previews: PreviewProvider &#123; static var previews: some View &#123; Home() &#125;&#125;struct MenuRow: View &#123; var image = &quot;creditcard&quot; var text = &quot;我的账户&quot; var body: some View &#123; HStack &#123; Image(systemName: image) .imageScale(.large) .foregroundColor(Color(&quot;icons&quot;)) .frame(width: 32, height: 32) Text(text) .font(.headline) &#125; &#125;&#125; 靠左处理 1234567891011121314VStack(alignment: .leading , spacing : 20) &#123; MenuRow(image: &quot;person.crop.circle&quot;, text: &quot;我的账户&quot;) MenuRow(image: &quot;creditcard&quot;, text: &quot;记账&quot;) MenuRow(image: &quot;person.and.person&quot;, text: &quot;团队&quot;) MenuRow(image: &quot;arrow.uturn.down&quot;, text: &quot;退出&quot;) Spacer()&#125;.padding(.top, 20)//顶边添加20.padding(30)//边距30.frame(minWidth: 0, maxWidth: .infinity).background(Color.white).cornerRadius(30).padding(.trailing, 60)//左边缘处理.shadow(radius: 20) 左对齐 使用数据创建列表使用数组创建模型对象 创建模型，进行拆分 菜单动画与其绑定 插入3d动画 将其变为MenuView（） 创建漂浮按钮创建按钮 12345678910HStack &#123; Spacer() Image(systemName: &quot;list.dash&quot;) .foregroundColor(.black)&#125;.padding(.trailing, 20).frame(width: 90, height: 60, alignment: /*@START_MENU_TOKEN@*/.center/*@END_MENU_TOKEN@*/).background(Color.white).cornerRadius(30).shadow(color:Color(&quot;buttonShadow&quot;), radius: 10, x: 0, y: 10) 让按钮靠边栏 1.frame(minWidth: 0, maxWidth: .infinity, minHeight: 0, maxHeight: .infinity, alignment: .topLeading) 将其变为CircleButton（） 提取变量 第二个图标显示 将其变为MenuButton（） 移动到此与右边按钮修复 将home带到主页 添加动画","categories":[],"tags":[]},{"title":"swiftui初探（1）","slug":"swiftui初探（1）","date":"2020-01-16T04:49:00.000Z","updated":"2020-01-18T06:49:00.000Z","comments":true,"path":"2020/01/16/swiftui初探（1）/","link":"","permalink":"http://example.com/2020/01/16/swiftui%E5%88%9D%E6%8E%A2%EF%BC%881%EF%BC%89/","excerpt":"","text":"前言：在这系列文章你可以学到swiftUI SWIFT——UI新建项目添加启动图片，和色彩背景等 设置第一张卡片 12345678910111213141516 var body: some View &#123; VStack &#123; VStack &#123;• Text(&quot;UI 设计&quot;) .font(.title) .fontWeight(.bold) .foregroundColor(Color(&quot;accent&quot;)) .padding(.top) Text(/*@START_MENU_TOKEN@*/&quot;合格证书&quot;/*@END_MENU_TOKEN@*/) .foregroundColor(Color(.white)) &#125; Image(&quot;Background&quot;) &#125; .background(Color.black).cornerRadius(10) &#125;&#125; 布局和和堆栈 123456789101112131415161718 HStack &#123; VStack(alignment: .leading) &#123;• Text(&quot;UI 设计&quot;) .font(.title) .fontWeight(.bold) .foregroundColor(Color(&quot;accent&quot;)) .padding(.top) Text(/*@START_MENU_TOKEN@*/&quot;合格证书&quot;/*@END_MENU_TOKEN@*/) .foregroundColor(Color(.white)) &#125; .padding(.horizontal) Spacer()//推动到屏幕宽度 Image(&quot;Logo&quot;) .resizable() .frame(width: 30.0, height: 30.0) &#125; Image(&quot;Background&quot;)&#125;.frame(width: 340.0, height: 220.0) 设置第二章卡片 12345678910111213141516171819202122232425262728293031323334353637ZStack &#123; VStack &#123; Text(&quot;背后的卡&quot;) &#125; .padding() .frame(width: 300.0, height: 220.0) .background(Color.blue) .cornerRadius(10) .shadow(radius: 20) .offset(x: 0, y: -20) VStack &#123; HStack &#123; VStack(alignment: .leading) &#123;• Text(&quot;UI 设计&quot;) .font(.headline) .fontWeight(.bold) .foregroundColor(Color(&quot;accent&quot;)) .padding(.top) Text(/*@START_MENU_TOKEN@*/&quot;合格证书&quot;/*@END_MENU_TOKEN@*/) .foregroundColor(Color(.white)) &#125; Spacer()//推动到屏幕宽度 Image(&quot;Logo&quot;) .resizable() .frame(width: 30.0, height: 30.0) &#125; .padding(.horizontal) Spacer() Image(&quot;Background&quot;) &#125; .frame(width: 340.0, height: 220.0) .background(Color.black) .cornerRadius(10) .shadow(radius: 20)&#125; 添加标题，动画，图片123456789101112131415161718192021222324252627282930313233 VStack &#123; HStack &#123; Text(&quot;合格证书&quot;) .font(.largeTitle) .fontWeight(.heavy) Spacer() &#125; Image(&quot;Illustration5&quot;) Spacer() &#125;.padding()//边距 CardView() .offset(x: 0, y: -40) .scaleEffect(0.85) .rotationEffect(Angle(degrees: 15)) .rotation3DEffect(Angle(degrees: 50), axis: /*@START_MENU_TOKEN@*/(x: 10.0, y: 10.0, z: 10.0)/*@END_MENU_TOKEN@*/) .blendMode(.hardLight) CardView() .offset(x: 0, y: -20) .scaleEffect(0.9) .rotationEffect(Angle(degrees: 10)) .rotation3DEffect(Angle(degrees: 40), axis: /*@START_MENU_TOKEN@*/(x: 10.0, y: 10.0, z: 10.0)/*@END_MENU_TOKEN@*/) .blendMode(.hardLight) CertificateView() .scaleEffect(0.95) .rotationEffect(Angle(degrees: 5)) .rotation3DEffect(Angle(degrees: 30), axis: /*@START_MENU_TOKEN@*/(x: 10.0, y: 10.0, z: 10.0)/*@END_MENU_TOKEN@*/)&#125; 添加正方形在中间 123456789101112VStack(spacing: 20.0) &#123; Rectangle()//添加正方形在中间 .frame(width: 60, height: 6) .cornerRadius(30) .opacity(0.1)//模糊度 Text(&quot;各个国家有各个国家的国歌，和某地的语言像极了鸟语。方言太多了，所以要统一语言，说出的话大家理解的都是同一份意思，这是小的，对于全球这么多国家，需要的是尊重各个国家的文化和历史，所以语言也是喽。&quot;) .lineLimit(10) Spacer() &#125; .padding() .background(Color.blue) .cornerRadius(30) 底部卡片向下移动 并将新设置的给提到下面 设置动画效果模糊效果 添加动画 123456789101112131415161718192021222324252627282930313233343536373839 @State var show = false var body: some View &#123; ZStack &#123; TitleView() .blur(radius: show ? 20 : 0)//模糊效果 .animation(.default) CarBottomView() .blur(radius: show ? 20 : 0)//模糊效果 .animation(.default) CardView() .offset(x: 0, y: show ? -400 : -40) .scaleEffect(0.85) .rotationEffect(Angle(degrees: show ? 15 : 0)) .rotation3DEffect(Angle(degrees: show ? 50 : 0), axis: /*@START_MENU_TOKEN@*/(x: 10.0, y: 10.0, z: 10.0)/*@END_MENU_TOKEN@*/) .blendMode(.hardLight) .animation(Animation.easeInOut(duration: 0.7)) CardView() .offset(x: 0, y: show ? -200 : -20) .scaleEffect(0.9) .rotationEffect(Angle(degrees: show ? 10 : 0)) .rotation3DEffect(Angle(degrees: show ? 40 : 0), axis: (x: 10.0, y: 10.0, z: 10.0)) .blendMode(.hardLight) .animation(Animation.easeInOut(duration: 0.5)) CertificateView() .scaleEffect(0.95) .rotationEffect(Angle(degrees: show ? 5 : 0)) .rotation3DEffect(Angle(degrees: show ? 30 : 0), axis: /*@START_MENU_TOKEN@*/(x: 10.0, y: 10.0, z: 10.0)/*@END_MENU_TOKEN@*/) .animation(.spring()) .onTapGesture &#123; self.show.toggle() &#125; &#125; &#125;&#125; 修改后面卡片颜色 手势和事件自由拖动第一张卡片 12345678910@State var viewState = CGSize.zero .offset(x: viewState.width, y: viewState.height) .gesture( DragGesture() .onChanged(&#123; (Value) in self.viewState = Value.translation &#125;) 卡片归位 让三张卡片同时拖动","categories":[],"tags":[]},{"title":"UIView的继承体系","slug":"UIView的继承体系","date":"2019-12-16T05:49:59.000Z","updated":"2019-12-16T06:49:00.000Z","comments":true,"path":"2019/12/16/UIView的继承体系/","link":"","permalink":"http://example.com/2019/12/16/UIView%E7%9A%84%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB/","excerpt":"","text":"UIView继承体系中的类具有不同的层次关系。其中，UIView继承自UIResponder，它提供了许多子类，如表示标签的UILabeI、表示图片的UIImageView、表示可交互控件的UIControI等。同样，UIControI类也提供了很多子类，比如表示按钮的UIButton、表示文本框的UITextFieId等。","categories":[],"tags":[]},{"title":"UIViewControllee的继承体系","slug":"UIViewControllee的继承体系","date":"2019-12-16T05:49:59.000Z","updated":"2019-12-16T06:49:00.000Z","comments":true,"path":"2019/12/16/UIViewControllee的继承体系/","link":"","permalink":"http://example.com/2019/12/16/UIViewControllee%E7%9A%84%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB/","excerpt":"","text":"UIViewControIIer作为视图控制器的父类，可以延伸出许多子视图控制器。下图为继承自UIViewControIIer的一些控制器组件，这些组件能够使应用程序的界面切换更加合理。目前，最流行的两种多视图控制器分别是导航控制器和标签页视图控制器。","categories":[],"tags":[]},{"title":"swift项目程序的启动原理","slug":"swift项目程序的启动原理","date":"2019-12-15T05:12:58.000Z","updated":"2019-12-15T06:49:00.000Z","comments":true,"path":"2019/12/15/swift项目程序的启动原理/","link":"","permalink":"http://example.com/2019/12/15/swift%E9%A1%B9%E7%9B%AE%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86/","excerpt":"","text":"程序启动的原理 当在OC创建的项目中，一定会有一个main.m文件，里面有一个main函数，可以在这个函数中启动App。但是在创建的Swift项目中，我们会发现，并没有名为main.swift的文件。因为Swift项目中添加了@UIAppIictationMain到Swift文件中，使得编译器默认生成了一个main函数，所以不需要main.swift文件。 启动的完整过程： （1）Swift应用程序在打开时，@UIAppIictationMain会自动生成main函数。 （2）main函数会调用UIAppIicationMain，创建UIAppIication对象和UIAppIication的代理对象。 （3）启动项目，分为两种情况： ① 不使用storyboard时，代理对象开始监听系统事件，在程序启动完毕时，调用代理的appIication:didFinishLaunchingWithOptions：方法，在方法中创建UIWindow，并创建和设置UIWindow的rootViewControIIer，最后显示窗口。 ② 使用storyboard时，会直接创建UIWindow，并创建UIWindow的rootViewControIIer，然后显示窗口。","categories":[],"tags":[]},{"title":"Object—C中定位和请求位置权限","slug":"OC中定位和请求位置权限","date":"2019-12-14T05:12:58.000Z","updated":"2022-02-01T06:49:00.000Z","comments":true,"path":"2019/12/14/OC中定位和请求位置权限/","link":"","permalink":"http://example.com/2019/12/14/OC%E4%B8%AD%E5%AE%9A%E4%BD%8D%E5%92%8C%E8%AF%B7%E6%B1%82%E4%BD%8D%E7%BD%AE%E6%9D%83%E9%99%90/","excerpt":"","text":"Object—C中定位和请求位置权限的处理 新建GTLocation(NSObject) 完成单例的类 12345678910111213141516171819202122232425#import &quot;GTLocation.h&quot;@interface GTLocation()@end@implementation GTLocation+ (GTLocation *)locationManager&#123; static GTLocation *location; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; location = [[GTLocation alloc] init]; &#125;); return location;&#125;- (instancetype)init&#123; self = [super init]; if (self) &#123; &#125; return self;&#125;@end 12345678910111213141516#import &lt;Foundation/Foundation.h&gt;NS_ASSUME_NONNULL_BEGIN/** App中统一的位置信息管理 */@interface GTLocation : NSObject+ (GTLocation *)locationManager;- (void)checkLocationAuthorization;@endNS_ASSUME_NONNULL_END 首次安装请求位置权限的获取 12345678910111213141516171819202122232425262728293031323334353637#import &lt;CoreLocation/CoreLocation.h&gt;@interface GTLocation()&lt;CLLocationManagerDelegate&gt;@property(nonatomic, strong, readwrite) CLLocationManager *manager; self.manager = [[CLLocationManager alloc] init]; self.manager.delegate = self; //判断APP相应的状态- (void)checkLocationAuthorization&#123; //判断系统是否开启 if(![CLLocationManager locationServicesEnabled])&#123; //引导弹窗 // &#125; if([CLLocationManager authorizationStatus] == kCLAuthorizationStatusNotDetermined)&#123; [self.manager requestWhenInUseAuthorization]; &#125;&#125;#pragma mark - delegate- (void)locationManager:(CLLocationManager *)manager didChangeAuthorizationStatus:(CLAuthorizationStatus)status&#123; if (status == kCLAuthorizationStatusAuthorizedWhenInUse) &#123; // [self.manager startUpdatingLocation]; &#125;else if (status == kCLAuthorizationStatusDenied)&#123; // &#125;&#125; 123#import &quot;GTLocation.h&quot;[[GTLocation locationManager] checkLocationAuthorization]; 获取当前位置信息 12345678910111213141516- (void)locationManager:(CLLocationManager *)manager didUpdateLocations:(NSArray&lt;CLLocation *&gt; *)locations &#123; //地理信息 CLLocation *location = [locations firstObject]; CLGeocoder *coder = [[CLGeocoder alloc] init]; [coder reverseGeocodeLocation:location completionHandler:^(NSArray&lt;CLPlacemark *&gt; * _Nullable placemarks, NSError * _Nullable error) &#123; //地标信息 &#125;]; [self.manager stopUpdatingLocation];&#125;","categories":[],"tags":[]},{"title":"OC中的推送","slug":"OC中的推送","date":"2019-12-14T05:12:58.000Z","updated":"2022-02-01T06:49:00.000Z","comments":true,"path":"2019/12/14/OC中的推送/","link":"","permalink":"http://example.com/2019/12/14/OC%E4%B8%AD%E7%9A%84%E6%8E%A8%E9%80%81/","excerpt":"","text":"Object-C中的本地推送 新建单例GTNotification(NSObject) 123456789101112131415161718192021222324252627#import &quot;GTNotification.h&quot;#import &lt;UserNotifications/UserNotifications.h&gt;@interface GTNotification ()&lt;UNUserNotificationCenterDelegate&gt;@end@implementation GTNotification+ (GTNotification *)notificationManager&#123; static GTNotification *manager; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; manager = [[GTNotification alloc] init]; &#125;); return manager;&#125;- (void)checkNotificationAuthorization&#123; UNUserNotificationCenter *center = [UNUserNotificationCenter currentNotificationCenter]; center.delegate = self; [center requestAuthorizationWithOptions:UNAuthorizationOptionBadge | UNAuthorizationOptionSound completionHandler:^(BOOL granted, NSError * _Nullable error) &#123; NSLog(@&quot;&quot;); &#125;];&#125;@end 12345678910111213141516#import &lt;Foundation/Foundation.h&gt;NS_ASSUME_NONNULL_BEGIN/** APP 推送管理 */@interface GTNotification : NSObject+ (GTNotification *)notificationManager;- (void)checkNotificationAuthorization;//效验权限的方法@endNS_ASSUME_NONNULL_END 123#import &quot;GTNotification.h&quot;[[GTNotification notificationManager] checkNotificationAuthorization]; 实现本地推送 1234567891011121314151617181920212223242526272829303132333435363738394041424344if (granted) &#123; //本地推送 [self _pushLocalNotification]; &#125; &#125;];&#125;#pragma mark -- (void)_pushLocalNotification&#123; UNMutableNotificationContent *content = [[UNMutableNotificationContent alloc] init]; content.badge = @(1); content.title = @&quot;北京时间&quot;; content.body = @&quot;这是一款iOS App&quot;; content.sound = [UNNotificationSound defaultSound]; UNTimeIntervalNotificationTrigger *trigger = [UNTimeIntervalNotificationTrigger triggerWithTimeInterval:30.f repeats:NO]; UNNotificationRequest *request = [UNNotificationRequest requestWithIdentifier:@&quot;_pushLocalNotification&quot; content:content trigger:trigger]; [[UNUserNotificationCenter currentNotificationCenter] addNotificationRequest:request withCompletionHandler:^(NSError * _Nullable error) &#123; // 2 #pragma mark -- (void)userNotificationCenter:(UNUserNotificationCenter *)center willPresentNotification:(UNNotification *)notification withCompletionHandler:(void (^)(UNNotificationPresentationOptions options))completionHandler&#123; completionHandler(UNNotificationPresentationOptionBanner);&#125;- (void)userNotificationCenter:(UNUserNotificationCenter *)center didReceiveNotificationResponse:(UNNotificationResponse *)response withCompletionHandler:(void(^)(void))completionHandler &#123; //处理badge展示逻辑 //点击之后根据业务逻辑处理 //[UIApplication sharedApplication].applicationIconBadgeNumber = 100; //处理业务逻辑 completionHandler();&#125;","categories":[],"tags":[]},{"title":"Swift用Delegate协议传值","slug":"Swift用Delegate协议传值","date":"2019-09-16T05:49:59.000Z","updated":"2019-09-16T06:49:00.000Z","comments":true,"path":"2019/09/16/Swift用Delegate协议传值/","link":"","permalink":"http://example.com/2019/09/16/Swift%E7%94%A8Delegate%E5%8D%8F%E8%AE%AE%E4%BC%A0%E5%80%BC/","excerpt":"","text":"一道面试题：有两个scene，分别为Scene A和Scene B。Scene A上有一个UIButton（Button A）和一个UILable（Lable A）；Scene B上有一个UITextFiled（textFiled）。当单击Scene A上的Button A时，跳转到Scene B，在Scene B的textFiled上输入文字，单击键盘的“完成”按钮，返典型的场景之间的跳转和逆向传值问。 采用Delegate模式，回到Scene A，并在Scene A的Lable A上显示刚才输入的内容。 iOS提供了多种方法，来实现页面之间的数据传递： 使用SharedApplication，定义一个类似全局的变量来传递 使用文件，或者使用NSUserdefault来传递 通过一个单例（SingleXX）的class来传递 通过Delegate来传递 SceneDelegate.swift1234567891011121314151617import UIKitclass SceneDelegate: UIResponder, UIWindowSceneDelegate &#123; var window: UIWindow? func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) &#123; guard let windowScene = (scene as? UIWindowScene) else &#123; return &#125; window = UIWindow(windowScene: windowScene) window = UIWindow(frame: UIScreen.main.bounds) window?.windowScene = windowScene let viewController = RootViewController() window?.rootViewController = viewController window?.makeKeyAndVisible() &#125; RootViewController.swift12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//// RootViewController.swift// Delegate//// Created by 朱官亮 on 2021/5/26.//import UIKit//实现ModeViewControlDelegate协议class RootViewController: UIViewController,MdoeViewControlDelegate&#123; var btn:UIButton? var label:UILabel? //实现协议中的方法 func changeLabel(neString newString:String) &#123; self.label!.text = newString &#125; @objc func btnOnClick()&#123; print(&quot;Onclick&quot;) let modeView = ModeViewController() //设置modeView中的代理为RootViewController自身 modeView.delegate=self //跳转到ModelView modeView.modalPresentationStyle = .fullScreen self.present(modeView,animated: true , completion: &#123; print(&quot;OK&quot;) &#125;) &#125; override func viewDidLoad() &#123; super.viewDidLoad() self.view.backgroundColor = UIColor.gray label = UILabel() label!.frame = CGRect(x: 110, y: 200, width: 100, height: 20) label!.backgroundColor = UIColor.white label!.text = &quot;你好！&quot; label!.textAlignment = .center btn = UIButton() btn!.frame = CGRect(x: 110, y: 240, width: 100, height: 20) btn!.backgroundColor = UIColor.green btn!.setTitle(&quot;下一视图&quot;, for: .normal) btn!.addTarget(self, action:#selector(RootViewController.btnOnClick), for: .touchUpInside) self.view.addSubview(label!) self.view.addSubview(btn!) &#125; override func didReceiveMemoryWarning() &#123; super.didReceiveMemoryWarning() // Dispose of any resources that can be recreated. &#125;&#125; MdoeViewControler.swift123456789101112131415161718192021222324252627282930313233343536373839404142import UIKitclass ModeViewController: UIViewController &#123; var textF:UITextField? var delegate:MdoeViewControlDelegate? //点击事件 @objc func btnOnClick()&#123; let str = textF?.text print(str as Any) // 调用代理函数 改变label值 self.delegate?.changeLabel(neString: str!) //返回RootView self.dismiss(animated: true, completion: nil) &#125; override func viewDidLoad() &#123; super.viewDidLoad() view.backgroundColor=UIColor.cyan textF=UITextField() textF!.frame=CGRect(x: 110,y: 200,width: 100,height: 20) textF!.backgroundColor=UIColor.white textF!.borderStyle = .roundedRect let btn=UIButton(frame:CGRect(x: 110,y: 240,width: 100,height: 20)) btn.backgroundColor=UIColor.orange btn.setTitle(&quot;返回上视图&quot;,for:.normal) //绑定事件 btn.addTarget(self,action:#selector(ModeViewController.btnOnClick),for: UIControl.Event.touchUpInside) self.view.addSubview(btn) self.view.addSubview(textF!) // Do any additional setup after loading the view. &#125;&#125; Protocol.swift12345import Foundation//协议定义要实现的方法protocol MdoeViewControlDelegate &#123; func changeLabel(neString:String)&#125;","categories":[],"tags":[]},{"title":"Swift版的自定义button的Demo","slug":"自定义button的Demo","date":"2019-09-13T04:49:00.000Z","updated":"2019-09-15T06:49:00.000Z","comments":true,"path":"2019/09/13/自定义button的Demo/","link":"","permalink":"http://example.com/2019/09/13/%E8%87%AA%E5%AE%9A%E4%B9%89button%E7%9A%84Demo/","excerpt":"","text":"Swift版的自定义button的Demo 具体代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186import UIKitenum States &#123; case open case close&#125;struct CustomColor &#123; static let brown:UIColor = UIColor.orange&#125;class ViewController: UIViewController &#123; var btnStatr:States? lazy var addBtn:UIButton = &#123; let btn = UIButton() btn.translatesAutoresizingMaskIntoConstraints = false btn.backgroundColor = UIColor.orange btn.showsTouchWhenHighlighted = true btn.adjustsImageWhenHighlighted = false //按钮按下发光 btn.layer.cornerRadius = 30 btn.addTarget(self, action: #selector(addBrnPressed), for: .touchUpInside) btn.setImage(UIImage(named: &quot;add&quot;), for: .normal) btn.layer.shadowOpacity = 0.8 //阴影区域透明度 btn.layer.shadowColor = UIColor.black.cgColor // 阴影区域颜色 btn.layer.shadowOffset = CGSize(width: 1, height: 1) //阴影区域范围 return btn &#125;() let btn1:UIButton = &#123; let btn = UIButton() btn.translatesAutoresizingMaskIntoConstraints = false btn.backgroundColor = .red btn.layer.cornerRadius = 25 btn.setImage(UIImage(named: &quot;add&quot;), for: .normal) btn.layer.shadowOpacity = 0.8 //阴影区域透明度 btn.layer.shadowColor = UIColor.black.cgColor // 阴影区域颜色 btn.layer.shadowOffset = CGSize(width: 1, height: 1) //阴影区域范围 return btn &#125;() let btn2:UIButton = &#123; let btn = UIButton() btn.translatesAutoresizingMaskIntoConstraints = false btn.backgroundColor = .red btn.layer.cornerRadius = 25 btn.setImage(UIImage(named: &quot;add&quot;), for: .normal) btn.layer.shadowOpacity = 0.8 //阴影区域透明度 btn.layer.shadowColor = UIColor.black.cgColor // 阴影区域颜色 btn.layer.shadowOffset = CGSize(width: 1, height: 1) //阴影区域范围 return btn &#125;() let btn3:UIButton = &#123; let btn = UIButton() btn.translatesAutoresizingMaskIntoConstraints = false btn.backgroundColor = .red btn.layer.cornerRadius = 25 btn.setImage(UIImage(named: &quot;add&quot;), for: .normal) btn.layer.shadowOpacity = 0.8 //阴影区域透明度 btn.layer.shadowColor = UIColor.black.cgColor // 阴影区域颜色 btn.layer.shadowOffset = CGSize(width: 1, height: 1) //阴影区域范围 return btn &#125;() let btn4:UIButton = &#123; let btn = UIButton() btn.translatesAutoresizingMaskIntoConstraints = false btn.backgroundColor = .red btn.layer.cornerRadius = 25 btn.setImage(UIImage(named: &quot;add&quot;), for: .normal) btn.layer.shadowOpacity = 0.8 //阴影区域透明度 btn.layer.shadowColor = UIColor.black.cgColor // 阴影区域颜色 btn.layer.shadowOffset = CGSize(width: 1, height: 1) //阴影区域范围 return btn &#125;() let btn5:UIButton = &#123; let btn = UIButton() btn.translatesAutoresizingMaskIntoConstraints = false btn.backgroundColor = .red btn.layer.cornerRadius = 25 btn.setImage(UIImage(named: &quot;add&quot;), for: .normal) btn.layer.shadowOpacity = 0.8 //阴影区域透明度 btn.layer.shadowColor = UIColor.black.cgColor // 阴影区域颜色 btn.layer.shadowOffset = CGSize(width: 1, height: 1) //阴影区域范围 return btn &#125;() override func viewDidLoad() &#123; super.viewDidLoad()// view.backgroundColor = CustomColor.brown view.addSubview(btn1) view.addSubview(btn2) view.addSubview(btn3) view.addSubview(btn4) view.addSubview(btn5) view.addSubview(addBtn) setUPConstraints() &#125; func setUPConstraints()&#123; NSLayoutConstraint.activate([ addBtn.heightAnchor.constraint(equalToConstant: 60), addBtn.widthAnchor.constraint(equalToConstant: 60), addBtn.centerXAnchor.constraint(equalTo: view.centerXAnchor, constant: 0), addBtn.centerYAnchor.constraint(equalTo: view.centerYAnchor, constant: 250), btn1.heightAnchor.constraint(equalToConstant: 50), btn1.widthAnchor.constraint(equalToConstant: 50), btn1.centerYAnchor.constraint(equalTo: view.centerYAnchor, constant: 250), btn1.centerXAnchor.constraint(equalTo: view.centerXAnchor), btn2.heightAnchor.constraint(equalToConstant: 50), btn2.widthAnchor.constraint(equalToConstant: 50), btn2.centerYAnchor.constraint(equalTo: view.centerYAnchor, constant: 250), btn2.centerXAnchor.constraint(equalTo: view.centerXAnchor), btn3.heightAnchor.constraint(equalToConstant: 50), btn3.widthAnchor.constraint(equalToConstant: 50), btn3.centerYAnchor.constraint(equalTo: view.centerYAnchor, constant: 250), btn3.centerXAnchor.constraint(equalTo: view.centerXAnchor), btn4.heightAnchor.constraint(equalToConstant: 50), btn4.widthAnchor.constraint(equalToConstant: 50), btn4.centerYAnchor.constraint(equalTo: view.centerYAnchor, constant: 250), btn4.centerXAnchor.constraint(equalTo: view.centerXAnchor), btn5.heightAnchor.constraint(equalToConstant: 50), btn5.widthAnchor.constraint(equalToConstant: 50), btn5.centerYAnchor.constraint(equalTo: view.centerYAnchor, constant: 250), btn5.centerXAnchor.constraint(equalTo: view.centerXAnchor), ]) &#125; @objc func addBrnPressed() &#123; if btnStatr == .close &#123; UIView.animate(withDuration: 0.7, delay: 0, usingSpringWithDamping: 1, initialSpringVelocity: 0, options: .curveEaseIn, animations: &#123; self.btn1.center.y += 100 self.btn2.center.y += 60 self.btn2.center.x += 90 self.btn3.center.y += 60 self.btn3.center.x -= 90 self.btn4.center.x += 120 self.btn4.center.y -= 20 self.btn5.center.x -= 120 self.btn5.center.y -= 20 self.addBtn.transform = .identity self.btnStatr = .open &#125;, completion: nil) &#125;else &#123; UIView.animate(withDuration: 0.7, delay: 0, usingSpringWithDamping: 0.7, initialSpringVelocity: 0, options: .curveEaseIn, animations: &#123; self.btn1.center.y -= 100 self.btn2.center.y -= 60 self.btn2.center.x -= 90 self.btn3.center.y -= 60 self.btn3.center.x += 90 self.btn4.center.x -= 120 self.btn4.center.y += 20 self.btn5.center.x += 120 self.btn5.center.y += 20 self.addBtn.transform = CGAffineTransform(rotationAngle: .pi/4) self.btnStatr = .close &#125;, completion: nil) &#125; &#125;&#125;","categories":[],"tags":[]},{"title":"模仿微博项目一","slug":"模仿微博项目一","date":"2019-08-16T05:49:59.000Z","updated":"2019-08-16T06:49:00.000Z","comments":true,"path":"2019/08/16/模仿微博项目一/","link":"","permalink":"http://example.com/2019/08/16/%E6%A8%A1%E4%BB%BF%E5%BE%AE%E5%8D%9A%E9%A1%B9%E7%9B%AE%E4%B8%80/","excerpt":"","text":"项目架构如下：创建项目诸葛微博，导入启动图片，设置应用名诸葛微博一般启动图片隐藏状态栏我们需要在info.plist文件里面增加一个键值对 运行程序，正常现实如下 设置项目的结构目录微博项目的主目录是CIasses，它用于存放所有的类文件，根据MVVM的特点，该文件夹包含4个子文件夹，分别是View、ViewModeI、ModeI、TooIs。 在View目录下，还需要创建一些子目录，这些子目录的相关说明如图。 创建各个控制器的模板文件底下四个界面都是以表格显示的，因此要使用表视图控制器（UITabIeViewControIIer） 创建好的文件目录结构： 删除ViewControIIer.swift文件，在AppDeIegate.swift文件中将标签控制器改为启动控制器，修改方式如下所示。 1234567var window: UIWindow?func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool &#123; window?.rootViewController = MainViewController() return true&#125; 删掉工程中main.storyboard ,删除plist文件中对应的键值外，还要删除其他的。具体如下 删除SceneDelegate.storyboard然后删除plist中Application Scene manifest。这个是iOS13后，在之前AppDelegate的基础上多出了一个SceneDelegate，会将AppDelegate里的lifecycle的那些代理方法转交给SceneDelegate 导入TabBar图片，设置底部导航条 在MainViewControIIer.swift文件中，给该类增加新的方法，用于添加4个控制器。1234567891011121314151617181920212223242526272829303132333435363738394041424344import UIKitclass MainViewController: UITabBarController &#123; override func viewDidLoad() &#123; super.viewDidLoad() // 使用kvc 完成只读属性赋值 setValue(tabBar, forKey: &quot;tabBar&quot;) addChildViewController(childController: HomeViewController(), title: &quot;首页&quot;, imgName: &quot;tabbar_home&quot;) addChildViewController(childController: MessageViewController(), title: &quot;消息&quot;, imgName: &quot;tabbar_message_center&quot;) addChildViewController(childController: DiscoverViewController(), title: &quot;发现&quot;, imgName: &quot;tabbar_discover&quot;) addChildViewController(childController: ProfileViewController(), title: &quot;我&quot;, imgName: &quot;tabbar_profile&quot;) &#125; /// 添加字控制器公共方法 /// /// - Parameters: /// - childController: 字控制器 /// - title: 名字 /// - imgName: 图片名 func addChildViewController(childController: UIViewController, title: String, imgName: String) &#123; // 设置title childController.navigationItem.title = title childController.tabBarItem.title = title // 选中的颜色 childController.tabBarItem.setTitleTextAttributes([NSAttributedString.Key.foregroundColor : UIColor.orange], for: UIControl.State.selected) // 设置image childController.tabBarItem.image = UIImage(named: imgName)?.withRenderingMode(UIImage.RenderingMode.alwaysOriginal) // 选中 // .withRenderingMode(UIImageRenderingMode.alwaysOriginal) 图片渲染 childController.tabBarItem.selectedImage = UIImage(named: &quot;\\(imgName)_selected&quot;)?.withRenderingMode(UIImage.RenderingMode.alwaysOriginal) // 导航控制器 let nav = UINavigationController(rootViewController: childController) // 添加子控制器 addChild(nav) &#125;&#125; 添加撰写按钮，在main文件下新建TabBar.swift继承自UITabBar 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import UIKitclass TabBar: UITabBar &#123; override init(frame: CGRect) &#123; super.init(frame: frame) setupUI() &#125; required init?(coder aDecoder: NSCoder) &#123; fatalError(&quot;init(coder:) has not been implemented&quot;) &#125; // 设置视图 private func setupUI()&#123; addSubview(composeButton) &#125; override func layoutSubviews() &#123; super.layoutSubviews() // 重写设置UITabBarButton的宽度 let w = frame.width * 0.2 // 记录遍历到第几个的标识 var index: CGFloat = 0 // 遍历子控件UITabBarButton for view in subviews&#123; // 判断是否是UITabBarButton(系统私有的) // NSClassFromString 通过字符串转出得到对应的class if view.isKind(of: NSClassFromString(&quot;UITabBarButton&quot;)!) &#123; print(view) // 宽度 view.frame.size.width = w // x轴 view.frame.origin.x = w * index // index 递增 index += 1 // 如果等于2 需要再加一 给撰写按钮.\b留位置 if index == 2 &#123; index += 1 &#125; &#125; &#125; // composeButton composeButton.center.x = frame.size.width * 0.5 composeButton.center.y = frame.size.height * 0.35 &#125; // 懒加载控件 // 撰写按钮 private lazy var composeButton: UIButton = &#123; let btn = UIButton() // image 和背景图片 btn.setBackgroundImage(UIImage(named:&quot;tabbar_compose_button_highlighted&quot;), for: UIControl.State.highlighted) btn.setBackgroundImage(UIImage(named:&quot;tabbar_compose_button&quot;), for: UIControl.State.normal) btn.setImage(UIImage(named:&quot;tabbar_compose_icon_add_highlighted&quot;), for: UIControl.State.highlighted) btn.setImage(UIImage(named:&quot;tabbar_compose_icon_add&quot;), for: UIControl.State.normal) btn.sizeToFit() return btn &#125;()&#125; 同时在MainViewControIIer.swift，添加上去 在Tools新建Extensions文件，添加EXT+UIBarButtonItem.swift1234567891011121314151617181920212223242526272829303132333435import UIKitextension UIBarButtonItem &#123; // 图片名 名字 target action convenience init(imgName: String?, title: String?, target: Any?, action: Selector)&#123; // 实例化一个按钮 let button = UIButton() // 监听事件 button.addTarget(target, action: action, for: UIControl.Event.touchUpInside) if let img = imgName &#123; // 图片 button.setImage(UIImage(named:img), for: UIControl.State.normal) button.setImage(UIImage(named:&quot;\\(img)_highlighted&quot;), for: UIControl.State.highlighted) &#125; if let tit = title &#123; // 文字 button.setTitle(tit, for: UIControl.State.normal) button.titleLabel?.font = UIFont.systemFont(ofSize: 14) button.setTitleColor(UIColor.darkGray, for: UIControl.State.normal) button.setTitleColor(UIColor.orange, for: UIControl.State.highlighted) &#125; button.sizeToFit() // 调用指定构造函数完成实例化 self.init(customView: button) &#125;&#125; 访客视图添加表视图控制器基类上一章搭建项目框架时，添加了四个子控制器，这些控制器都继承自UITabIeView ControIIer。由于这些控制器管理的页面有共同的地方，所以我们可以新建一个表格视图控制器的基类VisitorTabIeViewControIIer，该基类增加用户登录标记，根据用户登录标记判断是否加载默认视图，具体步骤如下。 （1）在Main目录下创建一个新的文件夹Visitor用来放置访客视图的类。 （2）在Visitor文件夹下创建一个继承自UITabIeViewControIIer的基类VisitorTabIeView ControIIer，如图所示。 同时将前面4个视图HomeViewController.swift、MessageTabIeViewControIIer.swift、DiscoverTabIe ViewControIIer.swift和ProfiIeTabIeViewControIIer.swift这几个类的父类修改为VisitorTabIe ViewControIIer。 新建的访客视图类VisitorTabIeViewControIIer中，实现根据用户标记切换根视图的代码1234567891011121314151617181920212223import UIKitclass VisitorTableViewController: UITableViewController &#123; //用户登录标记 private var userLogon = false override func viewDidLoad() &#123; super.viewDidLoad() userLogon ? super.loadView() : setupVisitorView() &#125; //设置访客视图 private func setupVisitorView ()&#123; view = UIView () view.backgroundColor = UIColor.orange &#125;&#125; 创建访客视图，导入访客视图的图片资源Visitor文件夹拖入Assets.xcassets文件目录中 在文件夹CIasses的子文件夹Visitor中新建一个继承自UIView的类VisitorView，创建好的文件如图 12345678910111213141516171819202122232425262728import UIKitclass VisitorView: UIView &#123; /// 图标，使用 image: 构造函数创建的 imageView 默认就是 image 的大小 private lazy var iconView: UIImageView = UIImageView (image: UIImage (named: &quot;visitordiscover_feed_image_smallicon&quot;)) ///// 小房子 private lazy var homeIconView: UIImageView = UIImageView (image: UIImage (named: &quot;visitordiscover_feed_image_house&quot;)) override init(frame: CGRect) &#123; super.init(frame: frame) setupUI() &#125; // initWithCoder - 使用 StoryBoard &amp; XIB 开发加载的函数 required init ? (coder aDecoder: NSCoder) &#123; super.init(coder:aDecoder) setupUI() &#125;&#125;extension VisitorView&#123; //设置界面 private func setupUI() &#123; addSubview(iconView) addSubview(homeIconView) &#125; &#125; 使用自动布局设置图片的位置我们已经将图片添加到了访客视图上，但是图片都堆在了左上角，所以我们需要对图片添加约束。使用纯代码设置自动布局时，首先需要把transIatesAutoresizingMaskInto Constraints属性设置为faIse，表示支持使用自动布局来设置控件位置。通过循环的方式，在setupUI（）方法中将subviews中的控件的transIatesAutoresizingMaskIntoConstraints属性设置为faIse，代码如下 123for v in subviews &#123; v.translatesAutoresizingMaskIntoConstraints = false&#125; 在下方添加自动布局代码 12345678910111213141516//图标 addConstraint(NSLayoutConstraint (item: iconView, attribute: .centerX, relatedBy: .equal, toItem: self, attribute: .centerX, multiplier: 1.0, constant: 0)) addConstraint(NSLayoutConstraint (item: iconView, attribute: .centerY, relatedBy: .equal, toItem: self, attribute: .centerY, multiplier: 1.0, constant: -60)) //房子 addConstraint(NSLayoutConstraint (item: homeIconView, attribute: .centerX, relatedBy: .equal, toItem: self, attribute: .centerX, multiplier: 1.0, constant: 0)) addConstraint(NSLayoutConstraint (item: homeIconView, attribute: .centerY, relatedBy: .equal, toItem: self, attribute: .centerY, multiplier: 1.0, constant: -60)) 完成图片的添加后，继续在VisitorView类中添加表示消息文字的懒加载控件IabeI 12345678910111213141516private lazy var messageLabel: UILabel = &#123; let label = UILabel() label.text = &quot;关注一些人，回这里看看有什么惊喜&quot; // 界面设计上，避免使用纯黑色 //设置label文字颜色 label.textColor = UIColor.darkGray //设置label字体大小 //设置label字体大小 label.font = UIFont.systemFont(ofSize: 14) //label文字不限制行数 label.numberOfLines = 0 //设置文字的对其方式 label.textAlignment = NSTextAlignment.center return label&#125;() 在设置界面方法setupUI（）中，首先通过addSubview方法添加messageLabeI控件，具体代码如下。1addSubview(messageLabel) 另外，还需要为messageLabeI添加约束，代码如下。123456789101112addConstraint(NSLayoutConstraint(item: messageLabel, attribute:.centerX, relatedBy: .equal, toItem: iconView, attribute: .centerX,multiplier: 1.0, constant: 0))addConstraint(NSLayoutConstraint(item: messageLabel, attribute: .top, relatedBy: .equal, toItem: iconView, attribute: .bottom,multiplier: 1.0, constant: 16))addConstraint(NSLayoutConstraint(item: messageLabel, attribute: .width, relatedBy: .equal, toItem: nil, attribute: .notAnAttribute,multiplier: 1.0, constant: 224))addConstraint(NSLayoutConstraint(item: messageLabel, attribute: .height, relatedBy: .equal, toItem: nil, attribute: .notAnAttribute,multiplier: 1.0, constant: 36)) 添加其他控件接下来，在消息文字IabeI下面添加“登录”和“注册”按钮，代码如下。 12345678910111213141516171819202122/// 注册按钮private lazy var registerButton: UIButton = &#123;let button = UIButton()//设置普通状态下按钮文字 button.setTitle(&quot;注册&quot;, for: UIControl.State.normal)//设置普通状态下按钮文字颜色 button.setTitleColor(UIColor.orange, for: UIControl.State.normal)//设置普通状态下按钮背景图片 button.setBackgroundImage(UIImage(named: &quot;common_button_white_disable&quot;), for: UIControl.State.normal)return button&#125;()/// 登录按钮private lazy var loginButton: UIButton = &#123;let button = UIButton() button.setTitle(&quot;登录&quot;, for: UIControl.State.normal) button.setTitleColor(UIColor.orange, for: UIControl.State.normal) button.setBackgroundImage(UIImage(named: &quot;common_button_white_disable&quot;), for: UIControl.State.normal)return button&#125;() 同样在设置界面方法setupUI()中添加控件,代码如下。 12addSubview(registerButton)addSubview(loginButton) 同样在设置界面方法setupUI()中添加控件,代码如下。 1234567891011addSubview(registerButton)addSubview(loginButton)在setupUI()中为注册和登录添加约束,代码如下。// 4＞ 注册按钮addConstraint(NSLayoutConstraint(item: registerButton, attribute: .Left,relatedBy: .equal, toItem: messageLabel, attribute: .Left,multiplier: 1.0, constant: 0))addConstraint(NSLayoutConstraint(item: registerButton,attribute: .Top, relatedBy: .equal, toItem: messageLabel, attribute: .Bottom,multiplier: 1.0, constant: 16))addConstraint(NSLayoutConstraint(item: registerButton, 在setupUI（）中为注册和登录添加约束，代码如下。 1234567891011121314151617181920212223242526272829// 4＞ 注册按钮addConstraint(NSLayoutConstraint(item: registerButton, attribute: .left,relatedBy: .equal, toItem: messageLabel, attribute: .left,multiplier: 1.0, constant: 0))addConstraint(NSLayoutConstraint(item: registerButton,attribute: .top, relatedBy: .equal, toItem: messageLabel, attribute: .bottom,multiplier: 1.0, constant: 16))addConstraint(NSLayoutConstraint(item: registerButton, attribute: .width, relatedBy: .equal, toItem: nil, attribute: .notAnAttribute,multiplier: 1.0, constant: 100))addConstraint(NSLayoutConstraint(item: registerButton, attribute: .height, relatedBy: .equal, toItem: nil, attribute: .notAnAttribute,multiplier: 1.0, constant: 36))// 5＞ 登录按钮addConstraint(NSLayoutConstraint(item: loginButton, attribute: .right, relatedBy: .equal, toItem: messageLabel, attribute: .right,multiplier: 1.0, constant: 0))addConstraint(NSLayoutConstraint(item: loginButton,attribute: .top, relatedBy: .equal, toItem: messageLabel, attribute: .bottom,multiplier: 1.0, constant: 16))addConstraint(NSLayoutConstraint(item: loginButton, attribute: .width, relatedBy: .equal, toItem: nil, attribute: .notAnAttribute,multiplier: 1.0, constant: 100))addConstraint(NSLayoutConstraint(item: loginButton, attribute: .height, relatedBy: .equal, toItem: nil, attribute: .notAnAttribute,multiplier: 1.0, constant: 36)) 添加遮罩视图，并使用VFL布局位置先在懒加载控件处添加遮罩图片控件，代码如下。 12/// 遮罩图像 private lazy var maskIconView: UIImageView = UIImageView (image: UIImage (named: &quot;visitordiscover_feed_mask_smallicon&quot;)) 接下来在setupUI（）方法中添加遮罩视图控件，需要注意的是，由于添加视图控件时，后添加的视图会位于之前添加的视图之上，这里，我们需要将添加遮罩视图的代码放在添加homeIconView和iconView之间 1addSubview(maskIconView) 下面使用addConstraints为遮罩视图添加约束，代码如下。12345678910111213141516//6.遮罩图像//view ： 定义VFL中的控件名称和实际名称的映射关系//metrics :定义 VFL 中（） 指定常数映射关系let viewDict = [&quot;maskIconView&quot;: maskIconView, &quot;registerButton&quot;: registerButton]let metrics = [&quot;spacing&quot;: -35]addConstraints(NSLayoutConstraint.constraints( withVisualFormat: &quot;H:|-0-[maskIconView]-0-|&quot;, options: [], metrics: nil, views: viewDict))addConstraints(NSLayoutConstraint.constraints( withVisualFormat: &quot;V:|-0-[maskIconView]-(spacing)-[registerButton]&quot;, options: [], metrics: metrics, views: viewDict)) 在遮罩视图下方会有白色的空白地带，如果调整约束为全屏，会导致遮罩图片无法遮挡圆圈的下半部分，那么在这里，我们可以通过修改访客视图的背景颜色用来达到同样的效果。在遮罩视图约束下面添加修改背景颜色的代码，代码如下。 12// 设置背景颜色 - 灰度图 R = G = B，在 UI 元素中，大多数都使用灰度图，或者纯色图（安全色）backgroundColor = UIColor.cz_color(withHex: 0xEDEDED) 根据前面描述的界面得知，各个控制器的图标和文字各不相同，所以我们需要设置视图信息，在VisitorView类中新建一个设置视图信息的方法setupInfo（），具体代码如下。 可以通过imageName参数传入每个控制需要显示的图片，通过titIe传入每个控制器需要显示的消息文字。设置视图的方法完成之后，我们可以看到，setupInfo是准备在VisitorView中的，而VisitorView则是在VisitorTabIeViewControIIer中定义的，所以在别的控制器中无法拿到VisitorView，那么，接下来修改VisitorTabIeViewControIIer中的代码，修改后的代码如下。 123456//访客视图var visitorView: VisitorView? //替换根视图 visitorView = VisitorView () view = visitorView 上面的代码中，首先声明一个访客视图，接下来在接收VisitorView，最后在将view替换成visitorView。接下来分别在其他控制器中访问VisitorView的setupInfo方法设置各个控制器的图片和消息文字。四个控制器中的代码分别如下。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import UIKitclass HomeViewController: VisitorTableViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() visitorView?.setupInfo(imageName: nil, title: &quot;关注一些人,回这里看看有什么惊喜&quot;) &#125;&#125;import UIKitclass MessageViewController: VisitorTableViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() visitorView?.setupInfo(imageName: &quot;visitordiscover_image_message&quot;, title: &quot;登录后,别人评论你的微博,发给你的消息,都会在这里收到通知&quot;) &#125;&#125;import UIKitclass DiscoverViewController: VisitorTableViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() visitorView?.setupInfo(imageName: &quot;visitordiscover_image_message&quot;, title: &quot;登录后,最新、最热微博尽在掌握,不再会与实事潮流擦肩而过&quot;) &#125;&#125;import UIKitclass ProfileViewController: VisitorTableViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() visitorView?.setupInfo(imageName: &quot;visitordiscover_image_profile&quot;, title: &quot;登录后,你的微博、相册、个人资料会显示在这里,展示给别人&quot;) &#125;&#125; 虽然图片已经设置完成，但是后面的界面中仍然显示了小房子图片和遮罩图像，这是因为在VisitorView中默认添加了小房子图片和遮罩图像，所以在这里如果不是首页，可以将小房子图片隐藏，并将遮罩图像移动到底层，在设置视图信息的方法setupInfo（）中，在guard Iet后面添加代码，代码如下。 为首页转轮图片设置动画转轮图片会一直转动，这种转动的效果是通过动画来实现的。接下来，在VisitorView类中声明一个开启首页转轮动画的方法startAnim（），代码如下 12345678910111213141516//旋转图标动画(首页)private func startAnimation() &#123; let anim = CABasicAnimation(keyPath: &quot;transform.rotation&quot;) anim.toValue = 2 * Double.pi anim.repeatCount = MAXFLOAT anim.duration = 15 //动画完成不删除，如果 iconView 被释放，动画一定会被销毁 //属性在设置连续播放动画非常有用 anim.isRemovedOnCompletion = false //将动画添加到图层 iconView.layer.add(anim, forKey: nil) &#125; 接下来在setupInfo方法的guard Iet中return之前调用转轮动画的方法，代码如下。 12//播插动画startAnimation() 运行发现有动画了","categories":[],"tags":[]},{"title":"oc版本的新闻App（9）","slug":"oc版本的新闻App（9）","date":"2019-04-22T04:49:00.000Z","updated":"2021-02-01T06:49:00.000Z","comments":true,"path":"2019/04/22/oc版本的新闻App（9）/","link":"","permalink":"http://example.com/2019/04/22/oc%E7%89%88%E6%9C%AC%E7%9A%84%E6%96%B0%E9%97%BBApp%EF%BC%889%EF%BC%89/","excerpt":"","text":"Crash的上报技术方案对比 12345#import &quot;GTStaicTest.h&quot;#include &lt;execinfo.h&gt;#import &lt;TencentOpenAPI/TencentOAuth.h&gt; 123456789101112 [self _caughtException]; [@[].mutableCopy addObject:nil];// static库的集成// [[GTStaicTest alloc] init]; //framework的集成 //[[GTFrameworkTest alloc] init]; //测试crash收集 //[self _caughtException]; //[@[].mutableCopy addObject:nil]; 123456789101112131415161718192021222324252627282930313233#pragma mark - CRASH- (void)_caughtException&#123; //NSexception NSSetUncaughtExceptionHandler(HandleNSException); //signal signal(SIGABRT, SignalExceptionHandler); signal(SIGILL, SignalExceptionHandler); signal(SIGSEGV, SignalExceptionHandler); signal(SIGFPE, SignalExceptionHandler); signal(SIGBUS, SignalExceptionHandler); signal(SIGPIPE, SignalExceptionHandler);&#125;void SignalExceptionHandler(int signal)&#123; void* callstack[128]; int frames = backtrace(callstack, 128); char **strs = backtrace_symbols(callstack, frames); NSMutableArray *backtrace = [NSMutableArray arrayWithCapacity:frames]; for (int i = 0; i &lt; frames; i++) &#123; [backtrace addObject:[NSString stringWithUTF8String:strs[i]]]; &#125; free(strs); //存储crash信息。&#125;void HandleNSException(NSException *exception)&#123; __unused NSString *reason = [exception reason]; __unused NSString *name = [exception name]; //存储crash信息。&#125; 定位和请求位置权限新建GTLocation(NSObject) 完成了单例的类 12345678910111213141516171819202122232425#import &quot;GTLocation.h&quot;@interface GTLocation()@end@implementation GTLocation+ (GTLocation *)locationManager&#123; static GTLocation *location; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; location = [[GTLocation alloc] init]; &#125;); return location;&#125;- (instancetype)init&#123; self = [super init]; if (self) &#123; &#125; return self;&#125;@end 12345678910111213141516#import &lt;Foundation/Foundation.h&gt;NS_ASSUME_NONNULL_BEGIN/** App中统一的位置信息管理 */@interface GTLocation : NSObject+ (GTLocation *)locationManager;- (void)checkLocationAuthorization;@endNS_ASSUME_NONNULL_END 首次安装请求位置权限的获取 12345678910111213141516171819202122232425262728293031323334353637#import &lt;CoreLocation/CoreLocation.h&gt;@interface GTLocation()&lt;CLLocationManagerDelegate&gt;@property(nonatomic, strong, readwrite) CLLocationManager *manager; self.manager = [[CLLocationManager alloc] init]; self.manager.delegate = self; //判断APP相应的状态- (void)checkLocationAuthorization&#123; //判断系统是否开启 if(![CLLocationManager locationServicesEnabled])&#123; //引导弹窗 // &#125; if([CLLocationManager authorizationStatus] == kCLAuthorizationStatusNotDetermined)&#123; [self.manager requestWhenInUseAuthorization]; &#125;&#125;#pragma mark - delegate- (void)locationManager:(CLLocationManager *)manager didChangeAuthorizationStatus:(CLAuthorizationStatus)status&#123; if (status == kCLAuthorizationStatusAuthorizedWhenInUse) &#123; // [self.manager startUpdatingLocation]; &#125;else if (status == kCLAuthorizationStatusDenied)&#123; // &#125;&#125; 123#import &quot;GTLocation.h&quot;[[GTLocation locationManager] checkLocationAuthorization]; 获取当前位置信息 12345678910111213141516- (void)locationManager:(CLLocationManager *)manager didUpdateLocations:(NSArray&lt;CLLocation *&gt; *)locations &#123; //地理信息 CLLocation *location = [locations firstObject]; CLGeocoder *coder = [[CLGeocoder alloc] init]; [coder reverseGeocodeLocation:location completionHandler:^(NSArray&lt;CLPlacemark *&gt; * _Nullable placemarks, NSError * _Nullable error) &#123; //地标信息 &#125;]; [self.manager stopUpdatingLocation];&#125; 推送新建单例GTNotification(NSObject) 123456789101112131415161718192021222324252627#import &quot;GTNotification.h&quot;#import &lt;UserNotifications/UserNotifications.h&gt;@interface GTNotification ()&lt;UNUserNotificationCenterDelegate&gt;@end@implementation GTNotification+ (GTNotification *)notificationManager&#123; static GTNotification *manager; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; manager = [[GTNotification alloc] init]; &#125;); return manager;&#125;- (void)checkNotificationAuthorization&#123; UNUserNotificationCenter *center = [UNUserNotificationCenter currentNotificationCenter]; center.delegate = self; [center requestAuthorizationWithOptions:UNAuthorizationOptionBadge | UNAuthorizationOptionSound completionHandler:^(BOOL granted, NSError * _Nullable error) &#123; NSLog(@&quot;&quot;); &#125;];&#125;@end 12345678910111213141516#import &lt;Foundation/Foundation.h&gt;NS_ASSUME_NONNULL_BEGIN/** APP 推送管理 */@interface GTNotification : NSObject+ (GTNotification *)notificationManager;- (void)checkNotificationAuthorization;//效验权限的方法@endNS_ASSUME_NONNULL_END 123#import &quot;GTNotification.h&quot;[[GTNotification notificationManager] checkNotificationAuthorization]; 实现本地推送 1234567891011121314151617181920212223242526272829303132333435363738394041424344if (granted) &#123; //本地推送 [self _pushLocalNotification]; &#125; &#125;];&#125;#pragma mark -- (void)_pushLocalNotification&#123; UNMutableNotificationContent *content = [[UNMutableNotificationContent alloc] init]; content.badge = @(1); content.title = @&quot;北京时间&quot;; content.body = @&quot;这是一款iOS App&quot;; content.sound = [UNNotificationSound defaultSound]; UNTimeIntervalNotificationTrigger *trigger = [UNTimeIntervalNotificationTrigger triggerWithTimeInterval:30.f repeats:NO]; UNNotificationRequest *request = [UNNotificationRequest requestWithIdentifier:@&quot;_pushLocalNotification&quot; content:content trigger:trigger]; [[UNUserNotificationCenter currentNotificationCenter] addNotificationRequest:request withCompletionHandler:^(NSError * _Nullable error) &#123; // 2 #pragma mark -- (void)userNotificationCenter:(UNUserNotificationCenter *)center willPresentNotification:(UNNotification *)notification withCompletionHandler:(void (^)(UNNotificationPresentationOptions options))completionHandler&#123; completionHandler(UNNotificationPresentationOptionBanner);&#125;- (void)userNotificationCenter:(UNUserNotificationCenter *)center didReceiveNotificationResponse:(UNNotificationResponse *)response withCompletionHandler:(void(^)(void))completionHandler &#123; //处理badge展示逻辑 //点击之后根据业务逻辑处理 //[UIApplication sharedApplication].applicationIconBadgeNumber = 100; //处理业务逻辑 completionHandler();&#125;","categories":[],"tags":[]},{"title":"oc版本的新闻App（8）","slug":"oc版本的新闻App（8）","date":"2019-04-21T04:49:00.000Z","updated":"2021-02-01T06:49:00.000Z","comments":true,"path":"2019/04/21/oc版本的新闻App（8）/","link":"","permalink":"http://example.com/2019/04/21/oc%E7%89%88%E6%9C%AC%E7%9A%84%E6%96%B0%E9%97%BBApp%EF%BC%888%EF%BC%89/","excerpt":"","text":"登陆与分享的逻辑 新建GTMineViewController（UIViewController），GTLogin（NSObject） 12345678910111213#import &lt;UIKit/UIKit.h&gt;NS_ASSUME_NONNULL_BEGIN/** 第四个Tab，我的页面 */@interface GTMineViewController : UIViewController@endNS_ASSUME_NONNULL_END 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#import &quot;GTMineViewController.h&quot;#import &quot;GTLogin.h&quot;#import &lt;SDWebImage.h&gt;@interface GTMineViewController ()&lt;UITableViewDelegate, UITableViewDataSource&gt;//实现Delegate，DataSource@property (nonatomic, strong, readwrite) UITableView *tableView;@property (nonatomic, strong, readwrite) UIView *tableViewHeaderView;@property (nonatomic, strong, readwrite) UIImageView *headerImageView;@end@implementation GTMineViewController- (instancetype)init &#123; self = [super init]; if (self) &#123; self.tabBarItem.title = @&quot;我的&quot;; self.tabBarItem.image = [UIImage imageNamed:@&quot;icon.bundle/home@2x.png&quot;]; self.tabBarItem.selectedImage = [UIImage imageNamed:@&quot;icon.bundle/home_selected@2x.png&quot;]; &#125; return self;&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; self.view.backgroundColor = [UIColor whiteColor]; [self.view addSubview:(&#123; _tableView = [[UITableView alloc] initWithFrame:self.view.bounds style:UITableViewStyleGrouped]; _tableView.delegate = self; _tableView.dataSource = self; _tableView; &#125;)];&#125;#pragma mark -- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section &#123; return 2;&#125;- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123; UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@&quot;mineTableViewCell&quot;]; if (!cell) &#123; cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:@&quot;mineTableViewCell&quot;]; &#125; return cell;&#125;- (nullable UIView *)tableView:(UITableView *)tableView viewForHeaderInSection:(NSInteger)section &#123; if (!_tableViewHeaderView) &#123; _tableViewHeaderView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, self.view.frame.size.width, 200)]; _tableViewHeaderView.backgroundColor = [UIColor whiteColor]; [_tableViewHeaderView addSubview:(&#123; _headerImageView = [[UIImageView alloc] initWithFrame:CGRectMake(0, 30, self.view.frame.size.width, 140)]; _headerImageView.backgroundColor = [UIColor whiteColor]; _headerImageView.contentMode = UIViewContentModeScaleAspectFit; _headerImageView.clipsToBounds = YES; _headerImageView.userInteractionEnabled = YES; _headerImageView; &#125;)]; [_tableViewHeaderView addGestureRecognizer:(&#123; UITapGestureRecognizer *tapGesture = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(_tapImage)]; tapGesture; &#125;)]; &#125; return _tableViewHeaderView;&#125;- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath &#123; return 60;&#125;- (CGFloat)tableView:(UITableView *)tableView heightForHeaderInSection:(NSInteger)section &#123; return 200;&#125;- (void)tableView:(UITableView *)tableView willDisplayHeaderView:(UIView *)view forSection:(NSInteger)section&#123; if (![[GTLogin sharedLogin] isLogin]) &#123; [_headerImageView setImage:[UIImage imageNamed:@&quot;icon.bundle/icon.png&quot;]]; &#125;else&#123; [self.headerImageView sd_setImageWithURL:[NSURL URLWithString:[GTLogin sharedLogin].avatarUrl]]; &#125;&#125;- (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath &#123; if (indexPath.row == 0) &#123; cell.textLabel.text = [[GTLogin sharedLogin] isLogin] ? [GTLogin sharedLogin].nick: @&quot;昵称&quot;; &#125; else &#123; cell.textLabel.text = [[GTLogin sharedLogin] isLogin] ? [GTLogin sharedLogin].address: @&quot;地区&quot;; &#125;&#125;#pragma mark -- (void)_tapImage &#123; __weak typeof(self) weakSelf = self; if (![[GTLogin sharedLogin] isLogin]) &#123; //没有登录的时候拉起登录 [[GTLogin sharedLogin] loginWithFinishBlock:^(BOOL isLogin) &#123; __strong typeof(weakSelf) strongSelf = weakSelf; //SDK流程之后判断是否登录成功 if (isLogin) &#123; [strongSelf.tableView reloadData]; &#125; &#125;]; &#125;else&#123; //已经登录的退出登录 [[GTLogin sharedLogin] logOut]; [self.tableView reloadData]; &#125;&#125;@end 1234567891011121314151617181920212223242526272829#import &lt;Foundation/Foundation.h&gt;NS_ASSUME_NONNULL_BEGINtypedef void(^GTLoginFinishBlock)(BOOL isLogin);/** QQ登录和分享相关逻辑 */@interface GTLogin : NSObject@property(nonatomic, strong, readonly)NSString *nick;@property(nonatomic, strong, readonly)NSString *address;@property(nonatomic, strong, readonly)NSString *avatarUrl;+ (instancetype)sharedLogin;#pragma - mark - 登录- (BOOL)isLogin;- (void)loginWithFinishBlock:(GTLoginFinishBlock)finishBlock;- (void)logOut;#pragma mark - 分享- (void)shareToQQWithArticleUrl:(NSURL *)articleUrl;@endNS_ASSUME_NONNULL_END 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#import &quot;GTLogin.h&quot;#import &lt;TencentOpenAPI/QQApiInterface.h&gt;#import &lt;TencentOpenAPI/TencentOAuth.h&gt;@interface GTLogin () &lt;TencentSessionDelegate&gt;@property (nonatomic, strong, readwrite) TencentOAuth *oauth;@property (nonatomic, copy, readwrite) GTLoginFinishBlock finishBlock;@property (nonatomic, assign, readwrite) BOOL isLogin;@end@implementation GTLogin+ (instancetype)sharedLogin &#123; static GTLogin *login; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; login = [[GTLogin alloc] init]; &#125;); return login;&#125;- (instancetype)init &#123; self = [super init]; if (self) &#123; _isLogin = NO; _oauth = [[TencentOAuth alloc] initWithAppId:@&quot;222222&quot; andDelegate:self]; &#125; return self;&#125;- (BOOL)isLogin &#123; //登陆态失效的逻辑 return _isLogin;&#125;- (void)loginWithFinishBlock:(GTLoginFinishBlock)finishBlock &#123; _finishBlock = [finishBlock copy]; _oauth.authMode = kAuthModeClientSideToken; [_oauth authorize:@[kOPEN_PERMISSION_GET_USER_INFO, kOPEN_PERMISSION_GET_SIMPLE_USER_INFO, kOPEN_PERMISSION_ADD_ALBUM, kOPEN_PERMISSION_ADD_ONE_BLOG, kOPEN_PERMISSION_ADD_SHARE, kOPEN_PERMISSION_ADD_TOPIC, kOPEN_PERMISSION_CHECK_PAGE_FANS, kOPEN_PERMISSION_GET_INFO, kOPEN_PERMISSION_GET_OTHER_INFO, kOPEN_PERMISSION_LIST_ALBUM, kOPEN_PERMISSION_UPLOAD_PIC, kOPEN_PERMISSION_GET_VIP_INFO, kOPEN_PERMISSION_GET_VIP_RICH_INFO]];&#125;- (void)logOut &#123; [_oauth logout:self]; _isLogin = NO;&#125;#pragma mark - delegate- (void)tencentDidLogin &#123; _isLogin = YES; //保存openid [_oauth getUserInfo];&#125;- (void)tencentDidNotLogin:(BOOL)cancelled &#123; if (_finishBlock) &#123; _finishBlock(NO); &#125;&#125;- (void)tencentDidNotNetWork &#123;&#125;- (void)tencentDidLogout &#123; //退出登录，需要清理下存储在本地的登录数据&#125;- (void)getUserInfoResponse:(APIResponse *)response &#123; NSDictionary *userInfo = response.jsonResponse; _nick = userInfo[@&quot;nickname&quot;]; _address = userInfo[@&quot;city&quot;]; _avatarUrl = userInfo[@&quot;figureurl_qq_2&quot;]; if (_finishBlock) &#123; _finishBlock(YES); &#125;&#125;#pragma mark -- (void)shareToQQWithArticleUrl:(NSURL *)articleUrl &#123; //登陆校验 //loginWithFinishBlock QQApiNewsObject *newsObj = [QQApiNewsObject objectWithURL:articleUrl title:@&quot;iOS&quot; description:@&quot;从0开始iOS开发&quot; previewImageURL:nil]; SendMessageToQQReq *req = [SendMessageToQQReq reqWithContent:newsObj]; __unused QQApiSendResultCode sent = [QQApiInterface SendReqToQZone:req];&#125;@end 进行代码的部分重构 123456789101112#pragma mark - lefe cycle- (instancetype)init &#123; self = [super init]; if (self) &#123; self.tabBarItem.title = @&quot;新闻&quot;; self.tabBarItem.image = [UIImage imageNamed:@&quot;icon.bundle/page@2x.png&quot;]; self.tabBarItem.selectedImage = [UIImage imageNamed:@&quot;icon.bundle/page_selected@2x.png&quot;]; 1#import &quot;GTMineViewController.h&quot; 12GTMineViewController *mineViewController = [[GTMineViewController alloc] init]; [tabbarConttroller setViewControllers:@[newsviewController,videoController,recimmendController,mineViewController]]; 同时新建库文件，导入第三方库添加文章分享功能 12345678910#import &quot;GTLogin.h&quot;self.navigationItem.rightBarButtonItem = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemAction target:self action:@selector(_shareArticle)];#pragma mark -- (void)_shareArticle&#123; [[GTLogin sharedLogin] shareToQQWithArticleUrl:[NSURL URLWithString:self.articleUrl]];&#125;","categories":[],"tags":[]},{"title":"oc版本的新闻App（7）","slug":"oc版本的新闻App（7）","date":"2019-04-20T04:49:00.000Z","updated":"2021-02-01T06:49:00.000Z","comments":true,"path":"2019/04/20/oc版本的新闻App（7）/","link":"","permalink":"http://example.com/2019/04/20/oc%E7%89%88%E6%9C%AC%E7%9A%84%E6%96%B0%E9%97%BBApp%EF%BC%887%EF%BC%89/","excerpt":"","text":"适配逻辑分辨率适配新建GTScreen，UIview的 1234567891011121314151617181920212223242526272829303132333435#import &lt;UIKit/UIKit.h&gt;NS_ASSUME_NONNULL_BEGIN//判断是否横竖屏#define IS_LANDSCAPE (UIInterfaceOrientationIsLandscape([[UIApplication sharedApplication] statusBarOrientation]))//横屏时屏幕的高度为宽度#define SCREEN_WIDTH (IS_LANDSCAPE ? [[UIScreen mainScreen ] bounds].size.height : [[UIScreen mainScreen ] bounds].size.width)//竖屏#define SCREEN_HEIGHT (IS_LANDSCAPE ? [[UIScreen mainScreen ] bounds].size.width : [[UIScreen mainScreen ] bounds].size.height)#define UI(x) UIAdapter(x)#define UIRect(x,y,width,height) UIRectAdapter(x,y,width,height)//按比例扩大或者缩小static inline NSInteger UIAdapter (float x)&#123; //1 - 分机型 特定的比例 //2 - 屏幕宽度按比例适配 CGFloat scale = 414 / SCREEN_WIDTH; // 414/当前屏幕的宽度 return (NSInteger)x /scale;&#125;//...完善其他方法..size..rect..origin..static inline CGRect UIRectAdapter(x,y,width,height)&#123; return CGRectMake(UIAdapter(x), UIAdapter(y), UIAdapter(width), UIAdapter(height));&#125;@interface GTScreen : NSObject@endNS_ASSUME_NONNULL_END 12345#import &quot;GTScreen.h&quot;self.titleLabel = [[UILabel alloc] initWithFrame:UIRect(20, 15, 270, 50)];self.sourceLabel = [[UILabel alloc] initWithFrame:UIRect(20, 70, 50, 20)]; iphoneX异形屏适配 12345#import &quot;GTScreen.h&quot;self.webView = [[WKWebView alloc] initWithFrame:CGRectMake(0, STATUSBARHEIGHT + 44, self.view.frame.size.width, self.view.frame.size.height - STATUSBARHEIGHT - 44)];self.progressView = [[UIProgressView alloc] initWithFrame:CGRectMake(0, STATUSBARHEIGHT + 44, self.view.frame.size.width, 50)]; 123456789//宏判断设备屏幕尺寸#define IS_IPHONE_X_XR_MAX (IS_IPHONE_X || IS_IPHONE_XR || IS_IPHONE_XMAX)#define IS_IPHONE_X (SCREEN_WIDTH == [GTScreen sizeFor58Inch].width &amp;&amp; SCREEN_HEIGHT == [GTScreen sizeFor58Inch].height)#define IS_IPHONE_XR (SCREEN_WIDTH == [GTScreen sizeFor61Inch].width &amp;&amp; SCREEN_HEIGHT == [GTScreen sizeFor61Inch].height &amp;&amp; [UIScreen mainScreen].scale == 2)#define IS_IPHONE_XMAX (SCREEN_WIDTH == [GTScreen sizeFor65Inch].width &amp;&amp; SCREEN_HEIGHT == [GTScreen sizeFor65Inch].height &amp;&amp; [UIScreen mainScreen].scale == 3)//如果是刘海屏返回44，如不是则返回20#define STATUSBARHEIGHT (IS_IPHONE_X_XR_MAX ? 44 : 20) 1234567891011//iphone xs max+ (CGSize)sizeFor65Inch;//iphone xr+ (CGSize)sizeFor61Inch;// iphonex+ (CGSize)sizeFor58Inch;//...其它机型 12345678910111213141516//iphone xs max+ (CGSize)sizeFor65Inch&#123; return CGSizeMake(414,896);&#125;//iphone xr+ (CGSize)sizeFor61Inch&#123; return CGSizeMake(414,896);&#125;// iphonex+ (CGSize)sizeFor58Inch&#123; return CGSizeMake(375,812);&#125;//plus//4 /5 启动图片的实现删掉storyboard 搜索填好 导入图片，创建GTSplashView 12345678910111213141516171819202122232425262728293031323334#import &quot;GTSplashView.h&quot;#import &quot;GTScreen.h&quot;@interface GTSplashView()@property(nonatomic, strong, readwrite)UIButton *button;@end@implementation GTSplashView- (instancetype)initWithFrame:(CGRect)frame&#123; self = [super initWithFrame:frame]; if (self) &#123; self.image = [UIImage imageNamed:@&quot;icon.bundle/splash.png&quot;]; [self addSubview:(&#123; _button = [[UIButton alloc] initWithFrame:UIRect(330, 100, 60, 40)]; _button.backgroundColor = [UIColor lightGrayColor]; [_button setTitle:@&quot;跳过&quot; forState:UIControlStateNormal]; [_button addTarget:self action:@selector(_removeSplashView) forControlEvents:UIControlEventTouchUpInside]; _button; &#125;)]; self.userInteractionEnabled = YES; &#125; return self;&#125;#pragma mark -- (void)_removeSplashView&#123; [self removeFromSuperview];&#125;@end 123456#import &quot;GTSplashView.h&quot;[self.window addSubview:(&#123; GTSplashView *splashView = [[GTSplashView alloc] initWithFrame:self.window.bounds]; splashView; &#125;)]; 使⽤ URL Scheme ⽀持 App 启动、跳转及参数传递URL Scheme 12345#pragma mark - URL SCHEME- (BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary&lt;UIApplicationOpenURLOptionsKey, id&gt; *)options&#123; return YES;&#125; 组件化Target-Action新建GTMediator 123456789101112#import &quot;GTMediator.h&quot;@implementation GTMediator+ (__kindof UIViewController *)detailViewControllerWithUrl:(NSString *)detailUrl&#123; Class detailCls = NSClassFromString(@&quot;GTDetailViewController&quot;); UIViewController *controller = [[detailCls alloc] performSelector:NSSelectorFromString(@&quot;initWithUrlString:&quot;) withObject:detailUrl]; return controller;&#125;@end 123@interface GTMediator : NSObject+ (__kindof UIViewController *)detailViewControllerWithUrl:(NSString *)detailUrl; 1234567#import &quot;GTMediator.h&quot; __kindof UIViewController *detailController = [GTMediator detailViewControllerWithUrl:item.articleUrl]; detailController.title = [NSString stringWithFormat:@&quot;%@&quot;,@(indexPath.row)];//设置标题，第几个显示第几 [self.navigationController pushViewController:detailController animated:YES];//推进新页面 使用URL scheme解耦 1234567891011#import &quot;GTMediator.h&quot;+ (void)load &#123; [GTMediator registerScheme:@&quot;detail://&quot; processBlock:^(NSDictionary * _Nonnull params) &#123; NSString *url = (NSString *)[params objectForKey:@&quot;url&quot;]; UINavigationController *navigationController = (UINavigationController *)[params objectForKey:@&quot;controller&quot;]; GTDetailViewController *controller = [[GTDetailViewController alloc] initWithUrlString:url];// controller.title = [NSString stringWithFormat:@&quot;%@&quot;, @(indexPath.row)]; [navigationController pushViewController:controller animated:YES]; &#125;];&#125; 1234//url schemetypedef void(^GTMediatorProcessBlock)(NSDictionary *params);//注册的函数+ (void)registerScheme:(NSString *)scheme processBlock:(GTMediatorProcessBlock)processBlock;//定义一个Block+ (void)openUrl:(NSString *)url params:(NSDictionary *)params;//openUrl传入参数 1234567891011121314151617181920212223#pragma mark -+ (NSMutableDictionary *)mediatorCache&#123; static NSMutableDictionary *cache; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; cache = @&#123;&#125;.mutableCopy; &#125;); return cache;&#125;+ (void)registerScheme:(NSString *)scheme processBlock:(GTMediatorProcessBlock)processBlock&#123; if (scheme &amp;&amp; processBlock) &#123; [[[self class] mediatorCache] setObject:processBlock forKey:scheme]; &#125;&#125;+ (void)openUrl:(NSString *)url params:(NSDictionary *)params&#123; GTMediatorProcessBlock block = [[[self class] mediatorCache] objectForKey:url]; if (block) &#123; block(params); &#125; &#125; 1[GTMediator openUrl:@&quot;detail://&quot; params:@&#123;@&quot;url&quot;:item.articleUrl,@&quot;controller&quot;:self.navigationController&#125;];","categories":[],"tags":[]},{"title":"oc版本的新闻App（6）","slug":"oc版本的新闻App（6）","date":"2019-04-19T04:49:00.000Z","updated":"2021-02-01T06:49:00.000Z","comments":true,"path":"2019/04/19/oc版本的新闻App（6）/","link":"","permalink":"http://example.com/2019/04/19/oc%E7%89%88%E6%9C%AC%E7%9A%84%E6%96%B0%E9%97%BBApp%EF%BC%886%EF%BC%89/","excerpt":"","text":"重构视频列表新建VideoController文件夹，将之前建好的放进去 新建GTVideoCoverView 12345678910111213141516#import &lt;UIKit/UIKit.h&gt;NS_ASSUME_NONNULL_BEGIN/** 视频ViewController collectionView Item */@interface GTVideoCoverView : UICollectionViewCell/** 根据数据布局，封面图&amp;播放 url */- (void)layoutWithVideoCoverUrl:(NSString *)videoCoverUrl videoUrl:(NSString *)videoUrl;@endNS_ASSUME_NONNULL_END 12345678910111213141516171819202122232425262728293031323334353637383940414243#import &quot;GTVideoCoverView.h&quot;@interface GTVideoCoverView ()@property (nonatomic, strong, readwrite) UIImageView *coverView;@property (nonatomic, strong, readwrite) UIImageView *playButton;@property (nonatomic, copy, readwrite) NSString *videoUrl;@end@implementation GTVideoCoverView- (instancetype)initWithFrame:(CGRect)frame &#123; self = [super initWithFrame:frame]; if (self) &#123; [self addSubview:(&#123; _coverView = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, frame.size.width, frame.size.height)]; _coverView; &#125;)]; [_coverView addSubview:(&#123; _playButton = [[UIImageView alloc] initWithFrame:CGRectMake((frame.size.width - 50)/2, (frame.size.height - 50)/2, 50, 50)]; _playButton.image = [UIImage imageNamed:@&quot;icon.bundle/ VIdeobofang.png&quot;]; _playButton; &#125;)]; //点击全部Item都支持播放 UITapGestureRecognizer *tapGesture = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(_tapToPlay)]; [self addGestureRecognizer:tapGesture]; &#125; return self;&#125;#pragma mark - public method- (void)layoutWithVideoCoverUrl:(NSString *)videoCoverUrl videoUrl:(NSString *)videoUrl &#123; _coverView.image = [UIImage imageNamed:videoCoverUrl]; _videoUrl = videoUrl;&#125;#pragma mark - private method- (void)_tapToPlay &#123; //在当前Item上播放视频 NSLog(@&quot;&quot;);&#125;@end 1#import &quot;GTVideoCoverView.h&quot; 123456789101112131415Scheme 1 flowLayout.itemSize = CGSizeMake(self.view.frame.size.width,self.view.frame.size.width / 16*9); 2 [collectionView registerClass:[GTVideoCoverView class] forCellWithReuseIdentifier:@&quot;GTVideoCoverView&quot;];//注册重用的cell 3 UICollectionViewCell *cell = [collectionView dequeueReusableCellWithReuseIdentifier:@&quot;GTVideoCoverView&quot; forIndexPath:indexPath]; if ([cell isKindOfClass:[GTVideoCoverView class]]) &#123; //方便讲解事例数据 [(GTVideoCoverView *)cell layoutWithVideoCoverUrl:@&quot;icon.bundle/Video.png&quot; videoUrl:@&quot;https://0x9.me/PzdXc&quot;]; &#125; 添加播放功能 1#import &lt;AVFoundation/AVFoundation.h&gt; 12345678910111213NSURL *videoURL = [NSURL URLWithString:_videoUrl];AVAsset *asset = [AVAsset assetWithURL:videoURL];AVPlayer *videoItem = [AVPlayerItem playerItemWithAsset:asset];AVPlayer *avPlayer = [AVPlayer playerWithPlayerItem:videoItem];AVPlayerLayer *playerLayer = [AVPlayerLayer playerLayerWithPlayer:avPlayer];playerLayer.frame = _coverView.bounds;[_coverView.layer addSublayer:playerLayer];[avPlayer play]; 1[(GTVideoCoverView *)cell layoutWithVideoCoverUrl:@&quot;icon.bundle/Video.png&quot; videoUrl:@&quot;http://sns-video-qc.xhscdn.com/d43514414bf02ff023c52b80362e914b663bdc83_v1_ln?sign=6bbeae5060160f3cd1f84e708c9413f7&amp;t=6001bad4&quot;]; 视频播放完成获得通知 1234 [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(_handlePlayEnd) name:AVPlayerItemDidPlayToEndTimeNotification object:nil];//注册通知&#125;return self;[[NSNotificationCenter defaultCenter] removeObserver:self];//移除 1234- (void) _handlePlayEnd&#123; NSLog(@&quot;&quot;);&#125; 播放完成退出播放操作 123@property (nonatomic, strong, readwrite) AVPlayerItem *videoItem;@property (nonatomic, strong, readwrite) AVPlayer *avPlayer;@property (nonatomic, copy, readwrite) AVPlayerLayer *playerLayer; 12345678910111213141516 _videoItem = [AVPlayerItem playerItemWithAsset:asset]; _avPlayer = [AVPlayer playerWithPlayerItem:_videoItem]; _playerLayer = [AVPlayerLayer playerLayerWithPlayer:_avPlayer]; _playerLayer.frame = _coverView.bounds; [_coverView.layer addSublayer:_playerLayer]; [_avPlayer play]; NSLog(@&quot;&quot;);&#125;- (void) _handlePlayEnd&#123; [_playerLayer removeFromSuperlayer]; _videoItem = nil; _avPlayer = nil; 通过KVO监听播放资源的状态 123456789101112131415 [_videoItem removeObserver:self forKeyPath:@&quot;status&quot;]; [_videoItem addObserver:self forKeyPath:@&quot;status&quot; options:NSKeyValueObservingOptionNew context:nil]; #pragma mark - KVO- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context&#123; if ([keyPath isEqualToString:@&quot;status&quot;]) &#123; if (((NSNumber *)[change objectForKey:NSKeyValueChangeNewKey]).integerValue == AVPlayerItemStatusReadyToPlay) &#123; [_avPlayer play]; &#125;else&#123; NSLog(@&quot;&quot;); &#125; &#125;&#125; 监听视频播放的缓冲与进度（1） 123456[_videoItem removeObserver:self forKeyPath:@&quot;loadedRimeRanges&quot;];[_videoItem addObserver:self forKeyPath:@&quot;loadedRimeRanges&quot; options:NSKeyValueObservingOptionNew context:nil];CMTime duration = _videoItem.duration;CGFloat videoDuration = CMTimeGetSeconds(duration); 12345678 [_avPlayer addPeriodicTimeObserverForInterval:CMTimeMake(1,1) queue:dispatch_get_main_queue() usingBlock:^(CMTime time) &#123; NSLog(@&quot;播放进度：%@&quot;,@(CMTimeGetSeconds(time))); &#125;]; [_avPlayer seekToTime:CMTimeMake(0, 1)]; [_avPlayer play];&#125; 12&#125;else if ([keyPath isEqualToString:@&quot;loadedRimeRanges&quot;])&#123; NSLog(@&quot;缓冲：%@&quot;,[change objectForKey:NSKeyValueChangeNewKey]); 监听视频播放的缓冲与进度（2）建立一个视频播放器 1234567891011121314151617181920#import &lt;Foundation/Foundation.h&gt;#import &lt;UIKit/UIKit.h&gt;NS_ASSUME_NONNULL_BEGIN@interface GTVideoPlayer : NSObject/** 全局播放器单例 */+ (GTVideoPlayer *)Player;/** 在指定View上 通过url播放视频 */- (void)playVideoWithUrl:(NSString *)videoUrl attachView:(UIView *)attachView;@endNS_ASSUME_NONNULL_END 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#import &quot;GTVideoPlayer.h&quot;#import &lt;AVFoundation/AVFoundation.h&gt;@interface GTVideoPlayer()@property (nonatomic, strong, readwrite) AVPlayerItem *videoItem;@property (nonatomic, strong, readwrite) AVPlayer *avPlayer;@property (nonatomic, copy, readwrite) AVPlayerLayer *playerLayer;@end@implementation GTVideoPlayer+ (GTVideoPlayer *)Player &#123; static GTVideoPlayer *player; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; player = [[GTVideoPlayer alloc] init]; &#125;); return player;&#125;- (void)playVideoWithUrl:(NSString *)videoUrl attachView:(UIView *)attachView&#123; //首先停止播放 [self _stopPlay]; //在当前Item上播放视频 NSURL *videoURL = [NSURL URLWithString:videoUrl]; AVAsset *asset = [AVAsset assetWithURL:videoURL]; _videoItem = [AVPlayerItem playerItemWithAsset:asset]; [_videoItem addObserver:self forKeyPath:@&quot;status&quot; options:NSKeyValueObservingOptionNew context:nil]; [_videoItem addObserver:self forKeyPath:@&quot;loadedRimeRanges&quot; options:NSKeyValueObservingOptionNew context:nil]; CMTime duration = _videoItem.duration; CGFloat videoDuration = CMTimeGetSeconds(duration); _avPlayer = [AVPlayer playerWithPlayerItem:_videoItem]; [_avPlayer addPeriodicTimeObserverForInterval:CMTimeMake(1,1) queue:dispatch_get_main_queue() usingBlock:^(CMTime time) &#123; NSLog(@&quot;播放进度：%@&quot;,@(CMTimeGetSeconds(time))); &#125;]; _playerLayer = [AVPlayerLayer playerLayerWithPlayer:_avPlayer]; _playerLayer.frame = attachView.bounds; [attachView.layer addSublayer:_playerLayer]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(_handlePlayEnd) name:AVPlayerItemDidPlayToEndTimeNotification object:nil];//注册通知 &#125;- (void)_stopPlay &#123; //移除监听 [[NSNotificationCenter defaultCenter] removeObserver:self]; [_playerLayer removeFromSuperlayer]; [_videoItem removeObserver:self forKeyPath:@&quot;status&quot;]; [_videoItem removeObserver:self forKeyPath:@&quot;loadedRimeRanges&quot;]; _videoItem = nil; _avPlayer = nil; NSLog(@&quot;&quot;);&#125;- (void) _handlePlayEnd&#123; [_avPlayer seekToTime:CMTimeMake(0, 1)]; [_avPlayer play];&#125;#pragma mark - KVO- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context&#123; if ([keyPath isEqualToString:@&quot;status&quot;]) &#123; if (((NSNumber *)[change objectForKey:NSKeyValueChangeNewKey]).integerValue == AVPlayerItemStatusReadyToPlay) &#123; [_avPlayer play]; &#125;else&#123; NSLog(@&quot;&quot;); &#125; &#125;else if ([keyPath isEqualToString:@&quot;loadedRimeRanges&quot;])&#123; NSLog(@&quot;缓冲：%@&quot;,[change objectForKey:NSKeyValueChangeNewKey]); &#125;&#125;@end 使用AutoLayout实现列表toolbar，并添加上相应图片新建GTVideoToolbar 12345678910111213#import &lt;UIKit/UIKit.h&gt;#define GTVideoToolbarHeight 60NS_ASSUME_NONNULL_BEGIN@interface GTVideoToolbar : UIView- (void)layoutWithModel:(id)model;@endNS_ASSUME_NONNULL_END 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170#import &quot;GTVideoToolbar.h&quot;@interface GTVideoToolbar ()@property (nonatomic, strong, readwrite) UIImageView *avatorImageView;@property (nonatomic, strong, readwrite) UILabel *nickLabel;@property (nonatomic, strong, readwrite) UIImageView *commentImageView;@property (nonatomic, strong, readwrite) UILabel *commentLabel;@property (nonatomic, strong, readwrite) UIImageView *likeImageView;@property (nonatomic, strong, readwrite) UILabel *likeLabel;@property (nonatomic, strong, readwrite) UIImageView *shareImageView;@property (nonatomic, strong, readwrite) UILabel *shareLabel;@end@implementation GTVideoToolbar- (instancetype)initWithFrame:(CGRect)frame &#123; self = [super initWithFrame:frame]; if (self) &#123; self.backgroundColor = [UIColor whiteColor]; [self addSubview:(&#123; _avatorImageView = [[UIImageView alloc] initWithFrame:CGRectZero]; _avatorImageView.layer.masksToBounds = YES; _avatorImageView.layer.cornerRadius = 15; _avatorImageView.translatesAutoresizingMaskIntoConstraints = NO; _avatorImageView; &#125;)]; [self addSubview:(&#123; _nickLabel = [[UILabel alloc] init]; _nickLabel.font = [UIFont systemFontOfSize:15]; _nickLabel.textColor = [UIColor lightGrayColor]; _nickLabel.translatesAutoresizingMaskIntoConstraints = NO; _nickLabel; &#125;)]; [self addSubview:(&#123; _commentImageView = [[UIImageView alloc] initWithFrame:CGRectZero]; _commentImageView.layer.masksToBounds = YES; _commentImageView.layer.cornerRadius = 15; _commentImageView.translatesAutoresizingMaskIntoConstraints = NO; _commentImageView; &#125;)]; [self addSubview:(&#123; _commentLabel = [[UILabel alloc] init]; _commentLabel.font = [UIFont systemFontOfSize:15]; _commentLabel.textColor = [UIColor lightGrayColor]; _commentLabel.translatesAutoresizingMaskIntoConstraints = NO; _commentLabel; &#125;)]; [self addSubview:(&#123; _likeImageView = [[UIImageView alloc] initWithFrame:CGRectZero]; _likeImageView.layer.masksToBounds = YES; _likeImageView.layer.cornerRadius = 15; _likeImageView.translatesAutoresizingMaskIntoConstraints = NO; _likeImageView; &#125;)]; [self addSubview:(&#123; _likeLabel = [[UILabel alloc] init]; _likeLabel.font = [UIFont systemFontOfSize:15]; _likeLabel.textColor = [UIColor lightGrayColor]; _likeLabel.translatesAutoresizingMaskIntoConstraints = NO; _likeLabel; &#125;)]; [self addSubview:(&#123; _shareImageView = [[UIImageView alloc] initWithFrame:CGRectZero]; _shareImageView.layer.masksToBounds = YES; _shareImageView.layer.cornerRadius = 15; _shareImageView.translatesAutoresizingMaskIntoConstraints = NO; _shareImageView.contentMode = UIViewContentModeScaleToFill; _shareImageView; &#125;)]; [self addSubview:(&#123; _shareLabel = [[UILabel alloc] init]; _shareLabel.font = [UIFont systemFontOfSize:15]; _shareLabel.textColor = [UIColor lightGrayColor]; _shareLabel.translatesAutoresizingMaskIntoConstraints = NO; _shareLabel; &#125;)]; &#125; return self;&#125;- (void)layoutWithModel:(id)model &#123; _avatorImageView.image = [UIImage imageNamed:@&quot;icon.bundle/icon.png&quot;]; _nickLabel.text = @&quot;北京时间&quot;; _commentImageView.image = [UIImage imageNamed:@&quot;comment&quot;]; _commentLabel.text = @&quot;100&quot;; _likeImageView.image = [UIImage imageNamed:@&quot;praise&quot;]; _likeLabel.text = @&quot;25&quot;; _shareImageView.image = [UIImage imageNamed:@&quot;share&quot;]; _shareLabel.text = @&quot;分享&quot;; [NSLayoutConstraint activateConstraints:@[ [NSLayoutConstraint constraintWithItem:_avatorImageView attribute:NSLayoutAttributeCenterY relatedBy:NSLayoutRelationEqual toItem:self attribute:NSLayoutAttributeCenterY multiplier:1 constant:0], [NSLayoutConstraint constraintWithItem:_avatorImageView attribute:NSLayoutAttributeLeft relatedBy:NSLayoutRelationEqual toItem:self attribute:NSLayoutAttributeLeft multiplier:1 constant:15], [NSLayoutConstraint constraintWithItem:_avatorImageView attribute:NSLayoutAttributeWidth relatedBy:NSLayoutRelationEqual toItem:nil attribute:NSLayoutAttributeNotAnAttribute multiplier:1 constant:30], [NSLayoutConstraint constraintWithItem:_avatorImageView attribute:NSLayoutAttributeHeight relatedBy:NSLayoutRelationEqual toItem:nil attribute:NSLayoutAttributeNotAnAttribute multiplier:1 constant:30], [NSLayoutConstraint constraintWithItem:_nickLabel attribute:NSLayoutAttributeCenterY relatedBy:NSLayoutRelationEqual toItem:_avatorImageView attribute:NSLayoutAttributeCenterY multiplier:1 constant:0], [NSLayoutConstraint constraintWithItem:_nickLabel attribute:NSLayoutAttributeLeft relatedBy:NSLayoutRelationEqual toItem:_avatorImageView attribute:NSLayoutAttributeRight multiplier:1 constant:0], ]]; NSString *vflString = @&quot;H:|-15-[_avatorImageView]-0-[_nickLabel]-(&gt;=0)-[_commentImageView(==_avatorImageView)]-0-[_commentLabel]-15-[_likeImageView(==_avatorImageView)]-0-[_likeLabel]-15-[_shareImageView(==_avatorImageView)]-0-[_shareLabel]-15-|&quot;; [NSLayoutConstraint activateConstraints:[NSLayoutConstraint constraintsWithVisualFormat:vflString options:NSLayoutFormatAlignAllCenterY metrics:nil views:NSDictionaryOfVariableBindings(_avatorImageView, _nickLabel, _commentImageView, _commentLabel, _likeImageView, _likeLabel, _shareImageView, _shareLabel)]];&#125;@end 123#import &quot;GTVideoToolbar.h&quot; flowLayout.itemSize = CGSizeMake(self.view.frame.size.width,self.view.frame.size.width / 16 * 9 + GTVideoToolbarHeight); 123456789101112131415#import &quot;GTVideoToolbar.h&quot;@property (nonatomic, strong, readwrite) GTVideoToolbar *toolbar;_coverView = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, frame.size.width, frame.size.height - GTVideoToolbarHeight)];_playButton = [[UIImageView alloc] initWithFrame:CGRectMake((frame.size.width - 50)/2, (frame.size.height - GTVideoToolbarHeight - 50)/2, 50, 50)];[self addSubview:(&#123;_toolbar = [[GTVideoToolbar alloc] initWithFrame:CGRectMake(0, _coverView.bounds.size.height, frame.size.width, GTVideoToolbarHeight)]; _toolbar; &#125;)];","categories":[],"tags":[]},{"title":"oc版本的新闻App（5）","slug":"oc版本的新闻App（5）","date":"2019-04-17T04:49:00.000Z","updated":"2021-02-01T06:49:00.000Z","comments":true,"path":"2019/04/17/oc版本的新闻App（5）/","link":"","permalink":"http://example.com/2019/04/17/oc%E7%89%88%E6%9C%AC%E7%9A%84%E6%96%B0%E9%97%BBApp%EF%BC%885%EF%BC%89/","excerpt":"","text":"处理点击cell事件 1- (instancetype)initWithUrlString:(NSString *)urlString; 1234567891011@property (nonatomic, copy, readwrite) NSString *articleUrl;- (instancetype)initWithUrlString:(NSString *)urlString &#123; self = [super init]; if (self) &#123; self.articleUrl = urlString; &#125; return self;&#125;[self.webView loadRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:self.articleUrl]]]; 123456#import &quot;GTListItem.h&quot; GTListItem *item = [self.dataArray objectAtIndex:indexPath.row]; GTDetailViewController *controller = [[GTDetailViewController alloc] initWithUrlString:item.articleUrl]; //创建UIViewController 文件管理1 1234[self _getSandBoxPath];NSArray *pathArray = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES); 文件管理2 123456789101112131415161718192021222324252627282930 NSArray *pathArray = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES); NSString *cachePath = [pathArray firstObject]; NSFileManager *fileManager = [NSFileManager defaultManager]; //创建文件夹 NSString *dataPath = [cachePath stringByAppendingPathComponent:@&quot;GTData&quot;]; NSError *creatError; [fileManager createDirectoryAtPath:dataPath withIntermediateDirectories:YES attributes:nil error:&amp;creatError]; //创建文件 NSString *listDataPath = [dataPath stringByAppendingPathComponent:@&quot;list&quot;]; NSData *listData = [@&quot;abc&quot; dataUsingEncoding:NSUTF8StringEncoding]; [fileManager createFileAtPath:listDataPath contents:listData attributes:nil]; //查询文件 BOOL fileExist = [fileManager fileExistsAtPath:listDataPath]; //删除// if(fileExist)&#123;// [fileManager removeItemAtPath:listDataPath error:nil];// &#125; NSFileHandle *fileHandler = [NSFileHandle fileHandleForUpdatingAtPath:listDataPath]; [fileHandler seekToEndOfFile]; [fileHandler writeData:[@&quot;def&quot; dataUsingEncoding:NSUTF8StringEncoding]]; [fileHandler synchronizeFile]; [fileHandler closeFile]; 序列化和反序列化 序列化 1@interface GTListItem : NSObject &lt;NSSecureCoding&gt; 12345678910111213141516171819202122232425262728293031#pragma mark - NSSecureCoding- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder&#123; self = [super init]; if (self) &#123; self.category = [aDecoder decodeObjectForKey:@&quot;category&quot;]; self.picUrl = [aDecoder decodeObjectForKey:@&quot;picUrl&quot;]; self.uniqueKey = [aDecoder decodeObjectForKey:@&quot;uniqueKey&quot;]; self.title = [aDecoder decodeObjectForKey:@&quot;title&quot;]; self.date = [aDecoder decodeObjectForKey:@&quot;date&quot;]; self.authorName = [aDecoder decodeObjectForKey:@&quot;authorName&quot;]; self.articleUrl = [aDecoder decodeObjectForKey:@&quot;articleUrl&quot;]; &#125; return self;&#125;- (void)encodeWithCoder:(NSCoder *)aCoder&#123; [aCoder encodeObject:self.category forKey:@&quot;category&quot;]; [aCoder encodeObject:self.picUrl forKey:@&quot;picUrl&quot;]; [aCoder encodeObject:self.uniqueKey forKey:@&quot;uniqueKey&quot;]; [aCoder encodeObject:self.title forKey:@&quot;title&quot;]; [aCoder encodeObject:self.date forKey:@&quot;date&quot;]; [aCoder encodeObject:self.authorName forKey:@&quot;authorName&quot;]; [aCoder encodeObject:self.articleUrl forKey:@&quot;articleUrl&quot;];&#125;+ (BOOL)supportsSecureCoding&#123; return YES;&#125;#pragma mark - public method 123__weak typeof(self) weakSelf = self;NSURLSessionDataTask *dataTask = [session dataTaskWithURL:listURL completionHandler:^(NSData *_Nullable data, NSURLResponse *_Nullable response, NSError *_Nullable error) &#123; __strong typeof(weakSelf) strongSelf = weakSelf; 123[weakSelf _archiveListDataWithArray:listItemArray.copy];- (void)_archiveListDataWithArray:(NSArray&lt;GTListItem *&gt; *)array&#123; 1NSData *listData = [NSKeyedArchiver archivedDataWithRootObject:array requiringSecureCoding:YES error:nil]; 序列化 12NSData *readListdata = [fileManager contentsAtPath:listDataPath];id unarchiveObj = [NSKeyedUnarchiver unarchivedObjectOfClasses:[NSSet setWithObjects:[NSArray class],[GTListItem class], nil] fromData:readListdata error:nil]; 对本地数据进行存取，不用网络请求读取本地数据 1234NSArray&lt;GTListItem *&gt; *listdata = [self _readDataFromLocal];if (listdata) &#123; finishBlock(YES, listdata);&#125; 123456789101112131415161718#pragma mark - private method- (NSArray&lt;GTListItem *&gt; *)_readDataFromLocal&#123; NSArray *pathArray = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES); NSString *cachePath = [pathArray firstObject]; NSString *listDataPath = [cachePath stringByAppendingPathComponent:@&quot;GTData/list&quot;]; NSFileManager *fileManager = [NSFileManager defaultManager]; NSData *readListData = [fileManager contentsAtPath:listDataPath]; id unarchiveObj = [NSKeyedUnarchiver unarchivedObjectOfClasses:[NSSet setWithObjects:[NSArray class],[GTListItem class], nil] fromData:readListData error:nil]; if ([unarchiveObj isKindOfClass:[NSArray class]] &amp;&amp; [unarchiveObj count] &gt; 0) &#123; return (NSArray&lt;GTListItem *&gt; *)unarchiveObj; &#125; return nil;;&#125; 新闻已读状态 1234567BOOL hasRead = [[NSUserDefaults standardUserDefaults] boolForKey:item.uniqueKey];if (hasRead) &#123; self.titleLabel.textColor = [UIColor lightGrayColor];&#125;else&#123; self.titleLabel.textColor = [UIColor blackColor];&#125; 1[[NSUserDefaults standardUserDefaults] setBool:**YES** forKey:item.uniqueKey]; NSthread多线程的运用 1234567NSThread *downloadImageThread = [[NSThread alloc] initWithBlock:^&#123; UIImage *image = [UIImage imageWithData:[NSData dataWithContentsOfURL:[NSURL URLWithString:item.picUrl]]]; self.rightImageView.image = image; &#125;];downloadImageThread.name = @&quot;downloadImageThread&quot;;[downloadImageThread start]; 运行程序发现流畅了很多，接下来把非主线程的下载执行结束跳转到主线程来 GCD 123456789dispatch_queue_global_t downloadQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);//非主队列dispatch_queue_main_t mainQueue = dispatch_get_main_queue();//主队列 dispatch_async(downloadQueue, ^&#123;//非主队列执行 UIImage *image = [UIImage imageWithData:[NSData dataWithContentsOfURL:[NSURL URLWithString:item.picUrl]]]; dispatch_async(mainQueue, ^&#123;//主队列执行 self.rightImageView.image = image; &#125;);&#125;); 图片下载与存储 1#import &quot;SDWebImage.h&quot; 12345[self.rightImageView sd_setImageWithURL:[NSURL URLWithString:item.picUrl] completed:^(UIImage * _Nullable image, NSError * _Nullable error, SDImageCacheType cacheType, NSURL * _Nullable imageURL) &#123; //处理业务逻辑，通过cacheType判断图片是否命中缓存 NSLog(@&quot;&quot;); &#125;];","categories":[],"tags":[]},{"title":"oc版本的新闻App（4）","slug":"oc版本的新闻App（4）","date":"2019-04-16T04:49:00.000Z","updated":"2021-02-01T06:49:00.000Z","comments":true,"path":"2019/04/16/oc版本的新闻App（4）/","link":"","permalink":"http://example.com/2019/04/16/oc%E7%89%88%E6%9C%AC%E7%9A%84%E6%96%B0%E9%97%BBApp%EF%BC%884%EF%BC%89/","excerpt":"","text":"代码规范和重构点击右键rename重命名ViewController为GTNewsViewController 同时修改 网络请求的实现新建GTListLoader 1234567891011#import &lt;Foundation/Foundation.h&gt;NS_ASSUME_NONNULL_BEGIN@interface GTListLoader : NSObject- (void)loadListData;@endNS_ASSUME_NONNULL_END 123456789101112#import &quot;GTListLoader.h&quot;@implementation GTListLoader- (void)loadListData&#123; NSString *urlString = @&quot;https://static001.geekbang.org/univer/classes/ios_dev/lession/45/toutiao.json&quot;; NSURL *listURL = [NSURL URLWithString:urlString]; NSLog(@&quot;&quot;);&#125;@end 1234567891011121314151617181920212223242526272829303132333435#import &quot;GTListLoader.h&quot;@interface GTNewsViewController()&lt;UITableViewDataSource,UITableViewDelegate,GTNormalTableViewCellDelegate&gt;@property(nonatomic,strong,readwrite) UITableView *tableView;@property(nonatomic,strong,readwrite) NSMutableArray *dataArray;@property(nonatomic,strong,readwrite) GTListLoader *listLoader;;@end@implementation GTNewsViewController- (instancetype)init&#123; self = [super init]; if(self)&#123; _dataArray = @[].mutableCopy; for(int i = 0;i&lt;20;i++)&#123; [_dataArray addObject:@(i)]; &#125; &#125; return self;&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; self.view.backgroundColor = [UIColor whiteColor]; _tableView = [[UITableView alloc] initWithFrame:self.view.bounds]; _tableView.dataSource = self; _tableView.delegate = self; [self.view addSubview:_tableView]; self.listLoader = [[GTListLoader alloc] init]; [self.listLoader loadListData];&#125; 创建NSURLSession 将Request封装成Task 12345 __unused NSURLRequest *listRequest = [NSURLRequest requestWithURL:listURL]; NSURLSession *session = [NSURLSession sharedSession];// 创建Task NSURLSessionDataTask *dataTask = [session dataTaskWithURL:listRequest]; 系统 NSURLSession 加载数据流程 创建 &amp; 使⽤默认 Session 通过地址和参数创建 Task 开始 &amp; 取消 Task 在 Handler 中处理数据 123456789101112 NSString *urlString = @&quot;https://static001.geekbang.org/univer/classes/ios_dev/lession/45/toutiao.json&quot;; NSURL *listURL = [NSURL URLWithString:urlString]; // __unused NSURLRequest *listRequest = [NSURLRequest requestWithURL:listURL]; NSURLSession *session = [NSURLSession sharedSession];// 创建Task NSURLSessionDataTask *dataTask = [session dataTaskWithURL:listURL completionHandler:^(NSData *_Nullable data, NSURLResponse *_Nullable response, NSError *_Nullable error) &#123; &#125;]; [dataTask resume]; 进行http请求的加载设置 可见收到了网络请求response数据 下载集成第三发库cocoapods 12345target &#x27;SampleApp&#x27; dopod &quot;AFNetworking&quot;end 1234567#import &lt;AFNetworking.h&gt; NSError *jsonError; id jsonObj = [NSJSONSerialization JSONObjectWithData:data options:0 error:&amp;jsonError]; NSLog(@&quot;&quot;); 构造mvc模式，新建GTListItem 列表结构化数组 12345678910111213/// 列表结构化数据@interface GTListItem : NSObject@property(nonatomic, copy, readwrite) NSString *category;@property(nonatomic, copy, readwrite) NSString *picUrl;@property(nonatomic, copy, readwrite) NSString *uniqueKey;@property(nonatomic, copy, readwrite) NSString *title;@property(nonatomic, copy, readwrite) NSString *date;@property(nonatomic, copy, readwrite) NSString *authorName;@property(nonatomic, copy, readwrite) NSString *articleUrl;//构造函数- (void)configWithDictionary:(NSDictionary *)dictionary; 12345678910- (void)configWithDictionary:(NSDictionary *)dictionary &#123; #warning 注意类型是否匹配 self.category = [dictionary objectForKey:@&quot;category&quot;]; self.picUrl = [dictionary objectForKey:@&quot;thumbnail_pic_s&quot;]; self.uniqueKey = [dictionary objectForKey:@&quot;uniquekey&quot;]; self.title = [dictionary objectForKey:@&quot;title&quot;]; self.date = [dictionary objectForKey:@&quot;date&quot;]; self.authorName = [dictionary objectForKey:@&quot;author_name&quot;]; self.articleUrl = [dictionary objectForKey:@&quot;url&quot;];&#125; 1234567891011121314151617#import &quot;GTListItem.h&quot;@implementation GTListLoader- (void)loadListData&#123; NSString *urlString = @&quot;http://v.juhe.cn/toutiao/index?type=keji&amp;key=9b36e7f06020e794a3547c5718bc114c&quot;; #warning 注意类型的检查 NSArray *dataArray = [((NSDictionary *)[((NSDictionary *)jsonObj) objectForKey:@&quot;result&quot;]) objectForKey:@&quot;data&quot;]; NSMutableArray *listItemArray = @[].mutableCopy; for (NSDictionary *info in dataArray) &#123; GTListItem *listItem = [[GTListItem alloc] init]; [listItem configWithDictionary:info]; [listItemArray addObject:listItem]; &#125; 结构化数据 1234567891011@class GTListItem;//声明GTListItemNS_ASSUME_NONNULL_BEGINtypedef void(^GTListLoaderFinishBlock)(BOOL success, NSArray&lt;GTListItem *&gt; *dataArray);/// 列表请求@interface GTListLoader : NSObject- (void)loadListDataWithFinishBlock:(GTListLoaderFinishBlock)finishBlock; 1234567891011@class GTListItem;//声明GTListItemNS_ASSUME_NONNULL_BEGINtypedef void(^GTListLoaderFinishBlock)(BOOL success, NSArray&lt;GTListItem *&gt; *dataArray);/// 列表请求@interface GTListLoader : NSObject- (void)loadListDataWithFinishBlock:(GTListLoaderFinishBlock)finishBlock; 1- (void)loadListDataWithFinishBlock:(GTListLoaderFinishBlock)finishBlock&#123; 12345dispatch_async(dispatch_get_main_queue(), ^&#123;//将整个回调放到主线程中 if (finishBlock) &#123; finishBlock(error == nil, listItemArray.copy); &#125; &#125;); 12345__weak typeof(self)wself = self;[self.listLoader loadListDataWithFinishBlock:^(BOOL success, NSArray&lt;GTListItem *&gt; * _Nonnull dataArray) &#123; __strong typeof(wself) strongSelf = wself; NSLog(@&quot;&quot;);&#125;]; 将数据展示到首页 1234567891011121314151617181920@class GTListItem;/** 点击删除按钮 */@protocol GTNormalTableViewCellDelegate &lt;NSObject&gt;- (void)tableViewCell:(UITableViewCell *)tableViewCell clickDeleteButton:(UIButton *)deleteButton;//实现点击的delegate@end/** 新闻列表cell */@interface GTNormalTableViewCell : UITableViewCell@property(nonatomic,weak,readwrite) id&lt;GTNormalTableViewCellDelegate&gt; delegate;//设置tableViewCell属性- (void)layoutTableViewCellWithItem:(GTListItem *)item; 123456789101112131415161718#import &quot;GTListItem.h&quot;- (void)layoutTableViewCellWithItem:(GTListItem *)item&#123; self.titleLable.text = item.title; self.sourceLable.text = item.authorName; [self.sourceLable sizeToFit]; self.commentLable.text = item.category; [self.commentLable sizeToFit]; self.commentLable.frame = CGRectMake(self.sourceLable.frame.origin.x + self.sourceLable.frame.size.width + 15, self.commentLable.frame.origin.y, self.commentLable.frame.size.width, self.commentLable.frame.size.height); self.timeLable.text = item.date; [self.timeLable sizeToFit]; self.timeLable.frame = CGRectMake(self.commentLable.frame.origin.x + self.commentLable.frame.size.width + 15, self.timeLable.frame.origin.y, self.timeLable.frame.size.width, self.timeLable.frame.size.height); UIImage *image = [UIImage imageWithData:[NSData dataWithContentsOfURL:[NSURL URLWithString:item.picUrl]]]; self.rightImageView.image = image; 1234567@property(nonatomic,strong,readwrite) NSArray *dataArray; strongSelf.dataArray = dataArray;//strongSelf赋值给dataArray [strongSelf.tableView reloadData];//刷新当前列表[cell layoutTableViewCellWithItem:[self.dataArray objectAtIndex:indexPath.row]]; 优化UItableView的布局 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106//// GTNormalTableViewCell.m// SampleApp//// Created by 朱官亮 on 2021/1/10.//#import &quot;GTNormalTableViewCell.h&quot;#import &quot;GTListItem.h&quot;@interface GTNormalTableViewCell ()@property(nonatomic,strong,readwrite) UILabel *titleLabel;@property(nonatomic,strong,readwrite) UILabel *sourceLabel;@property(nonatomic,strong,readwrite) UILabel *commentLabel;@property(nonatomic,strong,readwrite) UILabel *timeLabel;@property(nonatomic,strong,readwrite) UIImageView *rightImageView;//创建个UIImageView@property(nonatomic,strong,readwrite) UIButton *deleteButton;//创建个UIImageView@end@implementation GTNormalTableViewCell- (instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(nullable NSString *)reuseIdentifier&#123; self = [super initWithStyle:style reuseIdentifier:reuseIdentifier]; if(self)&#123; [self.contentView addSubview:(&#123; self.titleLabel = [[UILabel alloc] initWithFrame:CGRectMake(20, 15, 270, 50)]; // self.titleLabel.backgroundColor = [UIColor redColor]; self.titleLabel.font = [UIFont systemFontOfSize:16]; self.titleLabel.textColor = [UIColor blackColor]; self.titleLabel.numberOfLines = 2; self.titleLabel.lineBreakMode = NSLineBreakByTruncatingTail; self.titleLabel; &#125;)]; [self.contentView addSubview:(&#123; self.sourceLabel = [[UILabel alloc] initWithFrame:CGRectMake(20, 70, 50, 20)]; // self.sourceLabel.backgroundColor = [UIColor redColor]; self.sourceLabel.font = [UIFont systemFontOfSize:12]; self.sourceLabel.textColor = [UIColor grayColor]; self.sourceLabel; &#125;)]; [self.contentView addSubview:(&#123; self.commentLabel = [[UILabel alloc] initWithFrame:CGRectMake(100, 70, 50, 20)]; // self.commentLabel.backgroundColor = [UIColor redColor]; self.commentLabel.font = [UIFont systemFontOfSize:12]; self.commentLabel.textColor = [UIColor grayColor]; self.commentLabel; &#125;)]; [self.contentView addSubview:(&#123; self.timeLabel = [[UILabel alloc] initWithFrame:CGRectMake(150, 70, 50, 20)]; // self.timeLabel.backgroundColor = [UIColor redColor]; self.timeLabel.font = [UIFont systemFontOfSize:12]; self.timeLabel.textColor = [UIColor grayColor]; self.timeLabel; &#125;)]; [self.contentView addSubview:(&#123; self.rightImageView = [[UIImageView alloc] initWithFrame:CGRectMake(300, 15, 100, 70)]; self.rightImageView.backgroundColor = [UIColor redColor]; self.rightImageView; &#125;)];// [self.contentView addSubview:(&#123;// self.deleteButton = [[UIButton alloc] initWithFrame:CGRectMake(240, 80, 30, 20)];// [self.deleteButton setTitle:@&quot;X&quot; forState:UIControlStateNormal];// [self.deleteButton setTitle:@&quot;V&quot; forState:UIControlStateHighlighted];// [self.deleteButton addTarget:self action:@selector(deleteButtonClick) forControlEvents:UIControlEventTouchUpInside];//// self.deleteButton.layer.cornerRadius = 10;// self.deleteButton.layer.masksToBounds = YES;//// self.deleteButton.layer.borderColor = [UIColor lightGrayColor].CGColor;// self.deleteButton.layer.borderWidth = 2;//// self.deleteButton;// &#125;)]; &#125; return self;&#125;- (void)layoutTableViewCellWithItem:(GTListItem *)item&#123; self.titleLabel.text = item.title; self.sourceLabel.text = item.authorName; [self.sourceLabel sizeToFit]; self.commentLabel.text = item.category; [self.commentLabel sizeToFit]; self.commentLabel.frame = CGRectMake(self.sourceLabel.frame.origin.x + self.sourceLabel.frame.size.width + 15, self.commentLabel.frame.origin.y, self.commentLabel.frame.size.width, self.commentLabel.frame.size.height); self.timeLabel.text = item.date; [self.timeLabel sizeToFit]; self.timeLabel.frame = CGRectMake(self.commentLabel.frame.origin.x + self.commentLabel.frame.size.width + 15, self.timeLabel.frame.origin.y, self.timeLabel.frame.size.width, self.timeLabel.frame.size.height); UIImage *image = [UIImage imageWithData:[NSData dataWithContentsOfURL:[NSURL URLWithString:item.picUrl]]]; self.rightImageView.image = image;&#125;- (void)deleteButtonClick&#123; if(self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(tableViewCell:clickDeleteButton:)])&#123; [self.delegate tableViewCell:self clickDeleteButton:self.deleteButton]; &#125;&#125;@end","categories":[],"tags":[]},{"title":"oc版本的新闻App（3）","slug":"oc版本的新闻App（3）","date":"2019-04-15T04:49:00.000Z","updated":"2019-04-17T06:49:00.000Z","comments":true,"path":"2019/04/15/oc版本的新闻App（3）/","link":"","permalink":"http://example.com/2019/04/15/oc%E7%89%88%E6%9C%AC%E7%9A%84%E6%96%B0%E9%97%BBApp%EF%BC%883%EF%BC%89/","excerpt":"","text":"UIImage and UIImageView添加UIImageView 123456789101112@property(nonatomic,strong,readwrite) UIImageView *rightImageView;//创建个UIImageView [self.contentView addSubview:(&#123; self.rightImageView = [[UIImageView alloc] initWithFrame:CGRectMake(280, 15, 70, 70)]; self.rightImageView.backgroundColor = [UIColor redColor]; self.rightImageView; &#125;)]; self.rightImageView.image = [UIImage imageNamed:@&quot;icon.bundle/timg.jpg&quot;]; Add UIButton、点击和手势添加UIButton 123456789@property(nonatomic,strong,readwrite) UIButton *deleteButton;//创建个UIImageView [self.contentView addSubview:(&#123; self.deleteButton = [[UIButton alloc] initWithFrame:CGRectMake(240, 80, 30, 20)]; self.deleteButton.backgroundColor = [UIColor blueColor]; [self.deleteButton setTitle:@&quot;X&quot; forState:UIControlStateNormal]; [self.deleteButton setTitle:@&quot;V&quot; forState:UIControlStateHighlighted]; self.deleteButton; &#125;)]; UIButton和用户交互相关的逻辑 12345[self.deleteButton addTarget:self action:@selector(deleteButtonClick) forControlEvents:UIControlEventTouchUpInside]; - (void)deleteButtonClick&#123; NSLog(@&quot;deleteButtonClick&quot;);&#125; 识别用户在屏幕中的触摸UIGestureRecognizer在推荐页面上添加一个view 12345[view addSubview:(&#123; UIView *view = [[UIView alloc] initWithFrame:CGRectMake(100, 200, 100, 100)]; view.backgroundColor = [UIColor yellowColor]; view;&#125;)]; 创建点击的手势，只有点击黄才有反应其他没有 12345678UITapGestureRecognizer *tapGesture = [[UITapGestureRecognizer alloc]initWithTarget:self action:@selector(viewClick)];[view addGestureRecognizer:tapGesture];- (void)viewClick&#123; NSLog(@&quot;viewClick&quot;);&#125; 让其点击无或有反应 12345678@interface GTRecommendViewController ()&lt;UIScrollViewDelegate,UIGestureRecognizerDelegate&gt;tapGesture.delegate = self;- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer&#123; return YES;&#125; WKWebView and Delgate新建新的ViewController，GTDetailViewController 加载WKWebView到点击时显示 1234#import &quot;GTDetailViewController.h&quot;GTDetailViewController *controller = [[GTDetailViewController alloc]init]; GTDetailViewController代码如下123456789101112131415161718192021222324#import &quot;GTDetailViewController.h&quot;#import &lt;WebKit/WebKit.h&gt;@interface GTDetailViewController ()@property(nonatomic,strong,readwrite) WKWebView *webView;//添加WebView@end@implementation GTDetailViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view. [self.view addSubview:(&#123; self.webView = [[WKWebView alloc] initWithFrame:CGRectMake(0, 80, self.view.frame.size.width, self.view.frame.size.height - 88)];// self.webView.navigationDelegate = self; self.webView; &#125;)]; [self.webView loadRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:@&quot;https://www.thepaper.cn&quot;]]];&#125;@end 运行可以加载新闻页面 Delgate 12345678910@interface GTDetailViewController ()&lt;WKNavigationDelegate&gt;- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler&#123; NSLog(@&quot; &quot;); decisionHandler(WKNavigationActionPolicyAllow);&#125;- (void)webView:(WKWebView *)webView didFinishNavigation:(null_unspecified WKNavigation *)navigation&#123; NSLog(@&quot;&quot;);&#125; 观察者模式WebView加载进度的实现 KVO并展示页面加载进度 1234567891011- (void)dealloc&#123; [self.webView removeObserver:self forKeyPath:@&quot;estimatedProgress&quot;];&#125; [self.webView addObserver:self forKeyPath:@&quot;estimatedProgress&quot; options:NSKeyValueObservingOptionNew context:nil];//监听webView的属性 - (void)observeValueForKeyPath:(nullable NSString *)keyPath ofObject:(nullable id)object change:(nullable NSDictionary&lt;NSKeyValueChangeKey, id&gt; *)change context:(nullable void *)context&#123; NSLog(@&quot;&quot;);&#125; 给其加上进度的展示条，添加到navigationBar下面 @property(nonatomic,strong,readwrite) UIProgressView *progressView;//添加进度的展示条 [self.view addSubview:(&#123; self.progressView = [[UIProgressView alloc] initWithFrame:CGRectMake(0, 88, self.view.frame.size.width, 50)]; self.progressView; &#125;)]; self.progressView.progress = self.webView.estimatedProgress;//设置进度条的值 运行程序，进度条加上了 UIView动画完善界面的交互12345@protocol GTNormalTableViewCellDelegate &lt;NSObject&gt;- (void)tableViewCell:(UITableViewCell *)tableViewCell clickDeleteButton:(UIButton *)deleteButton;//实现点击的delegate@property(nonatomic,weak,readwrite) id&lt;GTNormalTableViewCellDelegate&gt; delegate;//设置tableViewCell属性 点击时的判断 123if(self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(tableViewCell:clickDeleteButton:)])&#123; [self.delegate tableViewCell:self clickDeleteButton:self.deleteButton]; &#125; 设置cell的delegate 12345678@interface ViewController()&lt;UITableViewDataSource,UITableViewDelegate,GTNormalTableViewCellDelegate&gt;cell.delegate = self;- (void)tableViewCell:(UITableViewCell *)tableViewCell clickDeleteButton:(UIButton *)deleteButton&#123; NSLog(@&quot;&quot;); &#125; 新建新的ViewController，GTDeleteCellView 1234567891011121314151617181920212223242526272829303132333435363738394041#import &quot;GTDeleteCellView.h&quot;@interface GTDeleteCellView ()@property(nonatomic,strong,readwrite)UIView *backgroudView;@property(nonatomic,strong,readwrite)UIButton *deleteButton;@end@implementation GTDeleteCellView- (instancetype)initWithFrame:(CGRect)frame&#123; self = [super initWithFrame:frame]; if(self)&#123; [self addSubview:(&#123; _backgroudView = [[UIView alloc] initWithFrame:self.bounds]; _backgroudView.backgroundColor = [UIColor blackColor]; _backgroudView.alpha = 0.5; _backgroudView; &#125;)]; [self addSubview:(&#123; _deleteButton = [[UIButton alloc] initWithFrame:CGRectMake(0, 0, 200, 200)]; [_deleteButton addTarget:self action:@selector(_clickButton) forControlEvents:UIControlEventTouchUpInside]; _deleteButton.backgroundColor = [UIColor blueColor]; _deleteButton; &#125;)]; &#125; return self;&#125;- (void)showDeleteView&#123; [[UIApplication sharedApplication].keyWindow addSubview:self];&#125;- (void)dismissDeleteView&#123; [self removeFromSuperview];&#125;-(void)_clickButton&#123; [self removeFromSuperview];&#125;@end 1234567- (void)showDeleteView;#import &quot;GTDeleteCellView.h&quot; GTDeleteCellView *deleteView = [[GTDeleteCellView alloc] initWithFrame:self.view.bounds]; [deleteView showDeleteView]; 同时添加个点击的手势 1234[_backgroudView addGestureRecognizer:(&#123; UITapGestureRecognizer *tapGesture = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(dismissDeleteView)]; tapGesture;&#125;)]; 现在不用点击蓝筐就关闭，简单动画的实现 还可以实现回弹效果 123[UIView animateWithDuration:1.f animations:^&#123; self.deleteButton.frame = CGRectMake((self.bounds.size.width - 200)/2, (self.bounds.size.height - 200)/2, 200, 200);&#125;]; 点击按钮时跳出修改上边代码为123456 [UIView animateWithDuration:1.f delay:0.f usingSpringWithDamping:0.5 initialSpringVelocity:0.5 options:UIViewAnimationOptionCurveEaseInOut animations:^&#123; self.deleteButton.frame = CGRectMake((self.bounds.size.width - 200)/2, (self.bounds.size.height - 200)/2, 200, 200); &#125; completion:^(BOOL finished)&#123; NSLog(@&quot;&quot;); &#125;];&#125; 1- (void)showDeleteViewFromPoint:(CGPoint)point clickBlock:(dispatch_block_t) clickBlock; 12345CGRect rect = [tableViewCell convertRect:deleteButton.frame toView:nil];[deleteView showDeleteViewFromPoint:rect.origin clickBlock:^&#123; NSLog(@&quot;&quot;);&#125;]; 123456789101112@property(nonatomic,copy,readwrite)dispatch_block_t deleteBlock;//加在上面的属性- (void)showDeleteViewFromPoint:(CGPoint)point clickBlock:(dispatch_block_t) clickBlock&#123; _deleteButton.frame = CGRectMake(point.x, point.y, 0, 0); _deleteBlock = [clickBlock copy]; if(_deleteBlock)&#123; _deleteBlock(); &#125; 点蓝删除 12345678910111213141516171819202122232425262728291@property(nonatomic,strong,readwrite) UITableView *tableView;@property(nonatomic,strong,readwrite) NSMutableArray *dataArray;2 _dataArray = @[].mutableCopy; for(int i = 0;i&lt;20;i++)&#123; [_dataArray addObject:@(i)]; &#125; &#125; 3 _tableView = [[UITableView alloc] initWithFrame:self.view.bounds]; _tableView.dataSource = self; _tableView.delegate = self; [self.view addSubview:_tableView]; 4 return _dataArray.count; 5 __weak typeof (self) wself = self; [deleteView showDeleteViewFromPoint:rect.origin clickBlock:^&#123; __strong typeof(self)strongSelf = wself; [strongSelf.dataArray removeLastObject]; [strongSelf.tableView deleteRowsAtIndexPaths:@[[strongSelf.tableView indexPathForCell:tableViewCell]] withRowAnimation:UITableViewRowAnimationAutomatic]; 使用CAlayer实现圆角同时把蓝色代码删掉 12345self.deleteButton.layer.cornerRadius = 10;self.deleteButton.layer.masksToBounds = YES;self.deleteButton.layer.borderColor = [UIColor lightGrayColor].CGColor;self.deleteButton.layer.borderWidth = 2;","categories":[],"tags":[]},{"title":"oc版本的新闻App（2）","slug":"oc版本的新闻App(2)","date":"2019-04-14T04:49:00.000Z","updated":"2019-04-15T06:49:00.000Z","comments":true,"path":"2019/04/14/oc版本的新闻App(2)/","link":"","permalink":"http://example.com/2019/04/14/oc%E7%89%88%E6%9C%AC%E7%9A%84%E6%96%B0%E9%97%BBApp(2)/","excerpt":"","text":"视频界面的布局UITableViewCell的升级版 UIConnetViewCell新建新的ViewController，GTVideoViewController 1#import &quot;GTVideoViewController.h&quot; 将视频下的代码剪切了带到GTVideoViewController 修改的GTVideoViewController代码如下 1234567891011121314151617@implementation GTVideoViewController-(instancetype) init&#123; self = [super init]; if(self)&#123; self.tabBarItem.title = @&quot;视频&quot;; self.tabBarItem.image = [UIImage imageNamed:@&quot;icon.bundle/video@2x.png&quot;]; self.tabBarItem.selectedImage = [UIImage imageNamed:@&quot;icon.bundle/video_selected@2x.png&quot;]; &#125; return self;&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; self.view.backgroundColor = [UIColor whiteColor];&#125; 添加上collectionView，并设置200个 12@interface GTVideoViewController ()&lt;UICollectionViewDelegate,UICollectionViewDataSource&gt;@end 1234567891011121314151617181920212223242526- (void)viewDidLoad &#123; [super viewDidLoad]; self.view.backgroundColor = [UIColor whiteColor]; UICollectionViewFlowLayout *flowLayout = [[UICollectionViewFlowLayout alloc] init]; UICollectionView *collectionView = [[UICollectionView alloc] initWithFrame:self.view.bounds collectionViewLayout:flowLayout]; collectionView.delegate = self; collectionView.dataSource = self; [collectionView registerClass:[UICollectionViewCell class] forCellWithReuseIdentifier:@&quot;UICollectionViewCell&quot;];//注册重用的cell [self.view addSubview:collectionView];&#125;- (NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section&#123; return 200;&#125;// The cell that is returned must be retrieved from a call to -dequeueReusableCellWithReuseIdentifier:forIndexPath:- (__kindof UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath&#123; UICollectionViewCell *cell = [collectionView dequeueReusableCellWithReuseIdentifier:@&quot;UICollectionViewCell&quot; forIndexPath:indexPath]; cell.backgroundColor = [UIColor redColor]; return cell;&#125; 使用UIcollectionView实现瀑布流效果collectionViewlayout的使用 123flowLayout.minimumLineSpacing = 10; //行间距flowLayout.minimumInteritemSpacing = 10; //item间的间距flowLayout.itemSize = CGSizeMake((self.view.frame.size.width - 10)/2,300); 1234567- (CGSize)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout*)collectionViewLayout sizeForItemAtIndexPath:(NSIndexPath *)indexPath&#123; if(indexPath.item %3 ==0)&#123; return CGSizeMake(self.view.frame.size.width,100); &#125;else&#123; return CGSizeMake((self.view.frame.size.width - 10)/2, 300); &#125;&#125; 推荐界面布局实现多个列表的横向滑动新建GTRecommendViewController，用作推进的视图控制器 在![image-20210110110027233](/Users/zhuguanliang/Library/Application Support/typora-user-images/image-20210110110027233.png?lastModify=1620831350) 然后它下面替换推荐列表 1234567GTRecommendViewController *recimmendController = [[GTRecommendViewController alloc] init];recimmendController.view.backgroundColor = [UIColor greenColor];recimmendController.tabBarItem.title = @&quot;推荐&quot;;recimmendController.tabBarItem.image = [UIImage imageNamed:@&quot;icon.bundle/like@2x.png&quot;];recimmendController.tabBarItem.selectedImage = [UIImage imageNamed:@&quot;icon.bundle/like_selected@2x.png&quot;];[tabbarConttroller setViewControllers:@[viewController,videoController,recimmendController,controller4]]; 将相关（绿色部分）逻辑剪切到GTRecommendViewController 123456789101112- (instancetype) init&#123; self = [super init]; if(self)&#123; self.tabBarItem.title = @&quot;推荐&quot;; self.tabBarItem.image = [UIImage imageNamed:@&quot;icon.bundle/like@2x.png&quot;]; self.tabBarItem.selectedImage = [UIImage imageNamed:@&quot;icon.bundle/like_selected@2x.png&quot;]; &#125; return self;&#125; self.view.backgroundColor = [UIColor whiteColor]; 推荐页面的ViewController完成 添加UIScrollView到推荐列表中 1234UIScrollView *scrollView = [[UIScrollView alloc] initWithFrame:self.view.bounds];scrollView.backgroundColor = [UIColor lightGrayColor];scrollView.contentSize = CGSizeMake(self.view.bounds.size.width * 5, self.view.bounds.size.height);//底部滚动条[self.view addSubview:scrollView]; 添加颜色翻页效果 1234567891011NSArray *colorArray = @[[UIColor redColor],[UIColor blueColor],[UIColor yellowColor],[UIColor lightGrayColor],[UIColor grayColor]];for(int i = 0;i &lt; 5; i++)&#123; [scrollView addSubview:(&#123; UIView *view = [[UIView alloc] initWithFrame:CGRectMake(scrollView.bounds.size.width * i, 0, scrollView.bounds.size.width, scrollView.bounds.size.height)]; view.backgroundColor = [colorArray objectAtIndex:i]; view; &#125;)];&#125;scrollView.pagingEnabled = YES; //翻页效果 UIScrollViewDelegate实现复杂逻辑的实现![image-20210110113319882](/Users/zhuguanliang/Library/Application Support/typora-user-images/image-20210110113319882.png?lastModify=1620831350) ![image-20210110113336979](/Users/zhuguanliang/Library/Application Support/typora-user-images/image-20210110113336979.png?lastModify=1620831350) ![image-20210110113402825](/Users/zhuguanliang/Library/Application Support/typora-user-images/image-20210110113402825.png?lastModify=1620831350) 12345678910111213141516171819202122232425262728293031@interface GTRecommendViewController ()&lt;UIScrollViewDelegate&gt; scrollView.delegate = self; - (void)scrollViewDidScroll:(UIScrollView *)scrollView&#123; // NSLog(@&quot;scrollViewDidScrollv - %@&quot;,@(scrollView.contentOffset.x));&#125;// called on start of dragging (may require some time and or distance to move)- (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView&#123; NSLog(@&quot;BeginDragging&quot;);//开始拖拽&#125;// called on finger up if the user dragged. decelerate is true if it will continue moving afterwards- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate&#123; NSLog(@&quot;EndDragging&quot;);//结束拖拽&#125;// called on finger up as we are moving- (void)scrollViewWillBeginDecelerating:(UIScrollView *)scrollView&#123; &#125;// called when scroll view grinds to a halt- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView&#123; &#125; 进行拖拽，控制台输出信息 scrollViewDidScroll也包含于UITableView，可以使用监测滚动 123-(void)scrollViewDidScroll:(UIScrollView *)scrollView &#123; NSLog(@&quot;scrollViewDidScroll&quot;);&#125; iOS中文字的展示：UILabel的使用与布局新建新的ViewController，GTNormalTableViewCell 替换掉 删掉之前测试UIView的代码 替换掉系统默认的 删掉创建的 2.在GTNormalTableViewCell创建自己的UIlabel 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#import &quot;GTNormalTableViewCell.h&quot;@interface GTNormalTableViewCell ()@property(nonatomic,strong,readwrite) UILabel *titleLable;@property(nonatomic,strong,readwrite) UILabel *sourceLable;@property(nonatomic,strong,readwrite) UILabel *commentLable;@property(nonatomic,strong,readwrite) UILabel *timeLable;@end@implementation GTNormalTableViewCell- (instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(nullable NSString *)reuseIdentifier&#123; self = [super initWithStyle:style reuseIdentifier:reuseIdentifier]; if(self)&#123; [self.contentView addSubview:(&#123; self.titleLable = [[UILabel alloc] initWithFrame:CGRectMake(20, 15, 300, 50)]; self.titleLable.backgroundColor = [UIColor redColor]; self.titleLable; &#125;)]; [self.contentView addSubview:(&#123; self.sourceLable = [[UILabel alloc] initWithFrame:CGRectMake(20, 80, 50, 20)]; self.sourceLable.backgroundColor = [UIColor redColor]; self.sourceLable.font = [UIFont systemFontOfSize:12]; self.sourceLable; &#125;)]; [self.contentView addSubview:(&#123; self.commentLable = [[UILabel alloc] initWithFrame:CGRectMake(100, 80, 50, 20)]; self.commentLable.backgroundColor = [UIColor redColor]; self.commentLable.font = [UIFont systemFontOfSize:12]; self.commentLable; &#125;)]; [self.contentView addSubview:(&#123; self.timeLable = [[UILabel alloc] initWithFrame:CGRectMake(150, 80, 50, 20)]; self.timeLable.backgroundColor = [UIColor redColor]; self.timeLable.font = [UIFont systemFontOfSize:12]; self.timeLable; &#125;)]; &#125; return self;&#125;@end 暴露方法 在每次需要布局的时候调用下 123- (void)layoutTableViewCell;[cell layoutTableViewCell]; 改GTNormalTableViewCell的UIlabel样式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556- (instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(nullable NSString *)reuseIdentifier&#123; self = [super initWithStyle:style reuseIdentifier:reuseIdentifier]; if(self)&#123; [self.contentView addSubview:(&#123; self.titleLable = [[UILabel alloc] initWithFrame:CGRectMake(20, 15, 300, 50)]; // self.titleLable.backgroundColor = [UIColor redColor]; self.titleLable.font = [UIFont systemFontOfSize:16]; self.titleLable.textColor = [UIColor blackColor]; self.titleLable; &#125;)]; [self.contentView addSubview:(&#123; self.sourceLable = [[UILabel alloc] initWithFrame:CGRectMake(20, 80, 50, 20)]; // self.sourceLable.backgroundColor = [UIColor redColor]; self.sourceLable.font = [UIFont systemFontOfSize:12]; self.sourceLable.textColor = [UIColor grayColor]; self.sourceLable; &#125;)]; [self.contentView addSubview:(&#123; self.commentLable = [[UILabel alloc] initWithFrame:CGRectMake(100, 80, 50, 20)]; // self.commentLable.backgroundColor = [UIColor redColor]; self.commentLable.font = [UIFont systemFontOfSize:12]; self.commentLable.textColor = [UIColor grayColor]; self.commentLable; &#125;)]; [self.contentView addSubview:(&#123; self.timeLable = [[UILabel alloc] initWithFrame:CGRectMake(150, 80, 50, 20)]; // self.timeLable.backgroundColor = [UIColor redColor]; self.timeLable.font = [UIFont systemFontOfSize:12]; self.timeLable.textColor = [UIColor grayColor]; self.timeLable; &#125;)]; &#125; return self;&#125;- (void)layoutTableViewCell&#123; self.titleLable.text = @&quot;这里这里这里demo&quot;; self.sourceLable.text = @&quot;这里demo&quot;; [self.sourceLable sizeToFit]; self.commentLable.text = @&quot;1666评论&quot;; [self.commentLable sizeToFit]; self.commentLable.frame = CGRectMake(self.sourceLable.frame.origin.x + self.sourceLable.frame.size.width + 15, self.commentLable.frame.origin.y, self.commentLable.frame.size.width, self.commentLable.frame.size.height); self.timeLable.text = @&quot;三分钟前&quot;; [self.timeLable sizeToFit]; self.timeLable.frame = CGRectMake(self.commentLable.frame.origin.x + self.commentLable.frame.size.width + 15, self.timeLable.frame.origin.y, self.timeLable.frame.size.width, self.timeLable.frame.size.height);&#125;@end","categories":[],"tags":[]},{"title":"oc版本的新闻App（1）","slug":"oc版本的新闻App(1)","date":"2019-04-13T04:49:00.000Z","updated":"2019-04-15T06:49:00.000Z","comments":true,"path":"2019/04/13/oc版本的新闻App(1)/","link":"","permalink":"http://example.com/2019/04/13/oc%E7%89%88%E6%9C%AC%E7%9A%84%E6%96%B0%E9%97%BBApp(1)/","excerpt":"","text":"前言：在这系列文章你可以学到以下 1.熟练使用 UI 组件搭建 App 界面；2.掌握 iOS 开发关键技术模块；3.构建系统的移动开发知识体系；4.具体独立开发完整 App 的能力。 新闻界面的布局新建OC项目，导入图片 在SceneDelegate.m添加TabBar代码 代码： 123456789101112131415161718192021222324252627282930313233343536 self.window = [[UIWindow alloc] initWithWindowScene:(UIWindowScene *)scene]; UITabBarController *tabbarConttroller = [[UITabBarController alloc] init]; UIViewController *controller1 = [[UIViewController alloc] init]; controller1.view.backgroundColor = [UIColor redColor]; controller1.tabBarItem.title = @&quot;新闻&quot;; controller1.tabBarItem.image = [UIImage imageNamed:@&quot;icon.bundle/page@2x.png&quot;]; controller1.tabBarItem.selectedImage = [UIImage imageNamed:@&quot;icon.bundle/page_selected@2x.png&quot;]; UIViewController *controller2 = [[UIViewController alloc] init]; controller2.view.backgroundColor = [UIColor yellowColor]; controller2.tabBarItem.title = @&quot;视频&quot;; controller2.tabBarItem.image = [UIImage imageNamed:@&quot;icon.bundle/video@2x.png&quot;]; controller2.tabBarItem.selectedImage = [UIImage imageNamed:@&quot;icon.bundle/video_selected@2x.png&quot;]; UIViewController *controller3 = [[UIViewController alloc] init]; controller3.view.backgroundColor = [UIColor greenColor]; controller3.tabBarItem.title = @&quot;推荐&quot;; controller3.tabBarItem.image = [UIImage imageNamed:@&quot;icon.bundle/like@2x.png&quot;]; controller3.tabBarItem.selectedImage = [UIImage imageNamed:@&quot;icon.bundle/like_selected@2x.png&quot;]; UIViewController *controller4 = [[UIViewController alloc] init]; controller4.view.backgroundColor = [UIColor lightGrayColor]; controller4.tabBarItem.title = @&quot;我的&quot;; controller4.tabBarItem.image = [UIImage imageNamed:@&quot;icon.bundle/home@2x.png&quot;]; controller4.tabBarItem.selectedImage = [UIImage imageNamed:@&quot;icon.bundle/home_selected@2x.png&quot;]; [tabbarConttroller setViewControllers:@[controller1,controller2,controller3,controller4]]; self.window.rootViewController = tabbarConttroller; [self.window makeKeyAndVisible];&#125; 使用Navigation bar进行页面的切换 代码： 1234567891011121314151617181920212223242526272829303132333435363738 self.window = [[UIWindow alloc] initWithWindowScene:(UIWindowScene *)scene]; UITabBarController *tabbarConttroller = [[UITabBarController alloc] init]; ViewController *viewController = [[ViewController alloc] init]; UINavigationController *navigationController = [[UINavigationController alloc] initWithRootViewController:viewController]; // UIViewController *controller1 = [[UIViewController alloc] init];// controller1.view.backgroundColor = [UIColor redColor]; navigationController.tabBarItem.title = @&quot;新闻&quot;; navigationController.tabBarItem.image = [UIImage imageNamed:@&quot;icon.bundle/page@2x.png&quot;]; navigationController.tabBarItem.selectedImage = [UIImage imageNamed:@&quot;icon.bundle/page_selected@2x.png&quot;]; UIViewController *controller2 = [[UIViewController alloc] init]; controller2.view.backgroundColor = [UIColor yellowColor]; controller2.tabBarItem.title = @&quot;视频&quot;; controller2.tabBarItem.image = [UIImage imageNamed:@&quot;icon.bundle/video@2x.png&quot;]; controller2.tabBarItem.selectedImage = [UIImage imageNamed:@&quot;icon.bundle/video_selected@2x.png&quot;]; UIViewController *controller3 = [[UIViewController alloc] init]; controller3.view.backgroundColor = [UIColor greenColor]; controller3.tabBarItem.title = @&quot;推荐&quot;; controller3.tabBarItem.image = [UIImage imageNamed:@&quot;icon.bundle/like@2x.png&quot;]; controller3.tabBarItem.selectedImage = [UIImage imageNamed:@&quot;icon.bundle/like_selected@2x.png&quot;]; UIViewController *controller4 = [[UIViewController alloc] init]; controller4.view.backgroundColor = [UIColor lightGrayColor]; controller4.tabBarItem.title = @&quot;我的&quot;; controller4.tabBarItem.image = [UIImage imageNamed:@&quot;icon.bundle/home@2x.png&quot;]; controller4.tabBarItem.selectedImage = [UIImage imageNamed:@&quot;icon.bundle/home_selected@2x.png&quot;]; [tabbarConttroller setViewControllers:@[navigationController,controller2,controller3,controller4]]; self.window.rootViewController = tabbarConttroller; [self.window makeKeyAndVisible];&#125; ViewController.m代码修改如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#import &quot;ViewController.h&quot;@interface TestView : UIView@end@implementation TestView- (instancetype) init&#123; self = [super init]; if(self)&#123; &#125; return self;&#125;- (void)willMoveToSuperview:(nullable UIView *)newSuperview&#123; [super willMoveToSuperview:newSuperview]; &#125;- (void)didMoveToSuperview&#123; [super didMoveToSuperview];&#125;- (void)willMoveToWindow:(nullable UIWindow *)newWindow&#123; [super willMoveToWindow:newWindow];&#125;- (void)didMoveToWindow&#123; [super didMoveToWindow]; &#125;@end@interface ViewController()@end@implementation ViewController- (instancetype)init&#123; self = [super init]; if(self)&#123; &#125; return self;&#125;- (void)viewWillAppear:(BOOL)animated&#123; [super viewWillAppear:animated];&#125; // Called when the view is about to made visible. Default does nothing- (void)viewDidAppear:(BOOL)animated&#123; [super viewDidAppear:animated];&#125; // Called when the view has been fully transitioned onto the screen. Default does nothing- (void)viewWillDisappear:(BOOL)animated&#123; [super viewWillDisappear:animated];&#125; // Called when the view is dismissed, covered or otherwise hidden. Default does nothing- (void)viewDidDisappear:(BOOL)animated&#123; [super viewDidDisappear:animated];&#125; // Called after the view was dismissed, covered or otherwise hidden. Default does nothing- (void)viewDidLoad &#123; [super viewDidLoad]; self.view.backgroundColor = [UIColor whiteColor]; // Do any additional setup after loading the view.// UIView *view = [[UIView alloc] init];// view.backgroundColor = [UIColor redColor];// view.frame = CGRectMake(100, 100, 100, 100);// [self.view addSubview:view]; TestView *view2 = [[TestView alloc] init]; view2.backgroundColor = [UIColor greenColor]; view2.frame = CGRectMake(150, 150, 100, 100); [self.view addSubview:view2]; // view 先入栈，view2 后入栈，view2显示在view上 &#125;@end 像绿色的View添加新的方法，点击时可以推进新的view黑色页面 123- (void)pushController&#123; [self.navigationController pushViewController:[[UIViewController alloc]init] animated:YES];&#125; 同时pull进去时给其添加白色背景，标题 1234567- (void)pushController&#123; UIViewController *viewController = [[UIViewController alloc]init]; viewController.view.backgroundColor = [UIColor whiteColor]; viewController.navigationItem.title = @&quot;内容&quot;; viewController.navigationItem.rightBarButtonItem = [[UIBarButtonItem alloc] initWithTitle:@&quot;右侧标题&quot; style:UIBarButtonItemStylePlain target:self action:nil]; [self.navigationController pushViewController:viewController animated:YES];&#125; 发现UInavigationController跳转底部TabBar还存在，去掉 后前对比图 1234567891011 viewController.tabBarItem.title = @&quot;新闻&quot;; viewController.tabBarItem.image = [UIImage imageNamed:@&quot;icon.bundle/page@2x.png&quot;]; viewController.tabBarItem.selectedImage = [UIImage imageNamed:@&quot;icon.bundle/page_selected@2x.png&quot;];[tabbarConttroller setViewControllers:@[viewController,controller2,controller3,controller4]]; UINavigationController *navigationController = [[UINavigationController alloc] initWithRootViewController:tabbarConttroller]; self.window.rootViewController = navigationController; delegate的使用1.先搞清楚谁是谁的代理(delegate) 2.定义代理协议,协议名称的命名规范:控件类名 + Delegate 3.定义代理方法 (1)代理方法一般都定义为@optional (2)代理方法名都以控件名开头 (3)代理方法至少有1个参数,将控件本身传递出去 4.设置代理(delegate)对象 (比如myView.delegate = xxxx;) (1)代理对象遵守协议 (2)代理对象实现协议里面该实现的方法 5.在恰当的时刻调用代理对象(delegate)的代理方法,通知代理发生了什么事情 (在调用之前判断代理是否实现了该代理方法) 1234567@interface SceneDelegate ()&lt;UITabBarControllerDelegate&gt; tabbarConttroller.delegate = self;- (void)tabBarController:(UITabBarController *)tabBarController didSelectViewController:(UIViewController *)viewController&#123; NSLog(@&quot;did select&quot;);&#125; 创建列表 把UI的逻辑删除掉，简单添加个UITableView 12UITableView *tableView = [[UITableView alloc] initWithFrame:self.view.bounds]; [self.view addSubview:tableView]; 同时添加一些数据 代码如下： 123456789101112131415161718192021@interface ViewController()&lt;UITableViewDataSource&gt; UITableView *tableView = [[UITableView alloc] initWithFrame:self.view.bounds]; tableView.dataSource = self; [self.view addSubview:tableView];&#125;- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section&#123; return 20;&#125;- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; UITableViewCell *cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier:@&quot;id&quot;]; cell.textLabel.text = @&quot;主标题&quot;; cell.detailTextLabel.text = @&quot;副标题&quot;; cell.imageView.image = [UIImage imageNamed:@&quot;icon.bundle/video&quot;]; return cell;&#125; UITableView delegate datasource 123456789101112131415161718192021222324252627282930@interface ViewController()&lt;UITableViewDataSource,UITableViewDelegate&gt; tableView.delegate = self; [self.view addSubview:tableView];&#125;- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath&#123; return 100;//高度&#125;- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath&#123; UIViewController *controller = [[UIViewController alloc]init]; //创建UIViewController controller.title = [NSString stringWithFormat:@&quot;%@&quot;,@(indexPath.row)];//设置标题，第几个显示第几 [self.navigationController pushViewController:controller animated:YES];//推进新页面&#125;- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section&#123; return 20;&#125;- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@&quot;id&quot;]; if(!cell)&#123; cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier:@&quot;id&quot;]; &#125; 第一部分完成整体运行App如下图","categories":[],"tags":[]}],"categories":[],"tags":[]}